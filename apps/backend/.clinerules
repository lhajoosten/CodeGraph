# Backend-Specific Claude Code Instructions

## Context
This is the FastAPI backend for CodeGraph. It handles API requests, manages agent orchestration via LangGraph, and integrates with PostgreSQL, Redis, and the Anthropic API.

## Technology Stack
- **Python**: 3.11+
- **Framework**: FastAPI with async/await
- **ORM**: SQLAlchemy 2.0 (async engine)
- **Validation**: Pydantic v2
- **AI**: LangChain + LangGraph + Anthropic
- **Database**: PostgreSQL 16 with asyncpg driver
- **Cache**: Redis with aioredis
- **Migrations**: Alembic
- **Testing**: pytest + pytest-asyncio + httpx
- **Dependency Management**: Poetry

## Project Structure

```
apps/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # FastAPI application entry point
│   ├── api/                    # API routes
│   │   ├── __init__.py
│   │   ├── deps.py            # Shared dependencies (auth, db)
│   │   ├── tasks.py           # Task endpoints
│   │   ├── agents.py          # Agent management endpoints
│   │   ├── repositories.py    # GitHub repository endpoints
│   │   └── users.py           # User/auth endpoints
│   ├── agents/                 # LangGraph agent implementations
│   │   ├── __init__.py
│   │   ├── base.py            # Base agent class
│   │   ├── planner.py         # Planning agent
│   │   ├── coder.py           # Coding agent (Sonnet/Opus)
│   │   ├── tester.py          # Testing agent
│   │   ├── reviewer.py        # Code review agent
│   │   └── workflows.py       # LangGraph workflow definitions
│   ├── models/                 # SQLAlchemy models
│   │   ├── __init__.py
│   │   ├── base.py            # Base model with common fields
│   │   ├── user.py
│   │   ├── task.py
│   │   ├── repository.py
│   │   ├── agent_run.py
│   │   └── code_change.py
│   ├── schemas/                # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── task.py
│   │   ├── repository.py
│   │   └── agent.py
│   ├── services/               # Business logic layer
│   │   ├── __init__.py
│   │   ├── task_service.py
│   │   ├── agent_service.py
│   │   ├── github_service.py
│   │   └── auth_service.py
│   ├── tools/                  # Agent tools
│   │   ├── __init__.py
│   │   ├── file_operations.py
│   │   ├── code_execution.py
│   │   ├── github_tools.py
│   │   └── code_analysis.py
│   ├── core/                   # Core configuration
│   │   ├── __init__.py
│   │   ├── config.py          # Settings (from env vars)
│   │   ├── database.py        # Database session management
│   │   ├── security.py        # JWT, password hashing
│   │   ├── logging.py         # Structured logging setup
│   │   └── exceptions.py      # Custom exceptions
│   └── utils/                  # Utility functions
│       ├── __init__.py
│       ├── github.py
│       ├── code_parser.py
│       └── streaming.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py            # pytest fixtures
│   ├── unit/                  # Unit tests
│   ├── integration/           # Integration tests
│   └── e2e/                   # End-to-end tests
├── alembic/                   # Database migrations
│   ├── versions/
│   └── env.py
├── pyproject.toml             # Poetry dependencies
├── alembic.ini               # Alembic configuration
├── .env.example              # Environment variables template
└── README.md
```

## Coding Standards

### Async/Await Everywhere
```python
# Good: Async all the way
async def get_task(db: AsyncSession, task_id: int) -> Task | None:
    result = await db.execute(
        select(Task).where(Task.id == task_id)
    )
    return result.scalar_one_or_none()

# Bad: Mixing sync and async
def get_task(db: AsyncSession, task_id: int) -> Task | None:
    # This won't work - can't use sync operations with async session
    return db.query(Task).filter(Task.id == task_id).first()
```

### Type Hints Always
```python
from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession
from src.models import Task
from src.schemas import TaskCreate

# Good: Full type hints
async def create_tasks(
    db: AsyncSession,
    tasks: List[TaskCreate],
    user_id: int
) -> List[Task]:
    """Create multiple tasks for a user."""
    created_tasks: List[Task] = []
    # Implementation
    return created_tasks

# Bad: No type hints
async def create_tasks(db, tasks, user_id):
    # Hard to understand what types are expected
    pass
```

### Dependency Injection Pattern
```python
# api/deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
from sqlalchemy.ext.asyncio import AsyncSession
from jose import jwt, JWTError

from src.core.database import get_db_session
from src.core.config import settings
from src.models import User

security = HTTPBearer()

async def get_current_user(
    db: AsyncSession = Depends(get_db_session),
    token: str = Depends(security)
) -> User:
    """Get current authenticated user from JWT token."""
    try:
        payload = jwt.decode(
            token.credentials,
            settings.SECRET_KEY,
            algorithms=["HS256"]
        )
        user_id: int = payload.get("sub")
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )

    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    return user

# api/tasks.py
from fastapi import APIRouter, Depends
from src.api.deps import get_current_user, get_db_session

router = APIRouter(prefix="/api/tasks")

@router.post("")
async def create_task(
    task_data: TaskCreate,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
) -> TaskResponse:
    # Dependencies injected automatically
    pass
```

### Service Layer Pattern
```python
# services/task_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from src.models import Task
from src.schemas import TaskCreate, TaskUpdate
from src.core.exceptions import TaskNotFoundError

class TaskService:
    """Service for task management operations."""

    async def create_task(
        self,
        db: AsyncSession,
        task_data: TaskCreate,
        user_id: int
    ) -> Task:
        """Create a new task."""
        task = Task(
            **task_data.model_dump(),
            user_id=user_id,
            status="pending"
        )
        db.add(task)
        await db.commit()
        await db.refresh(task)
        return task

    async def get_task(
        self,
        db: AsyncSession,
        task_id: int,
        user_id: int
    ) -> Task:
        """Get task by ID, ensuring user has access."""
        result = await db.execute(
            select(Task)
            .where(Task.id == task_id, Task.user_id == user_id)
        )
        task = result.scalar_one_or_none()
        if not task:
            raise TaskNotFoundError(f"Task {task_id} not found")
        return task

# Singleton instance
task_service = TaskService()
```

### Error Handling
```python
# core/exceptions.py
class CodeGraphException(Exception):
    """Base exception for CodeGraph."""
    pass

class TaskNotFoundError(CodeGraphException):
    """Task not found."""
    pass

class AgentExecutionError(CodeGraphException):
    """Agent execution failed."""
    pass

# api/tasks.py
from fastapi import APIRouter, HTTPException, status
from src.core.exceptions import TaskNotFoundError, AgentExecutionError

@router.get("/{task_id}")
async def get_task(task_id: int, ...):
    try:
        task = await task_service.get_task(db, task_id, current_user.id)
        return task
    except TaskNotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except AgentExecutionError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Agent execution failed"
        )
```

## Database Patterns

### SQLAlchemy 2.0 Async
```python
# models/task.py
from datetime import datetime
from sqlalchemy import Integer, String, Text, DateTime, ForeignKey, Enum
from sqlalchemy.orm import Mapped, mapped_column, relationship
import enum

from src.models.base import Base

class TaskStatus(enum.Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class Task(Base):
    __tablename__ = "tasks"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String(200), nullable=False)
    description: Mapped[str] = mapped_column(Text, nullable=False)
    status: Mapped[TaskStatus] = mapped_column(
        Enum(TaskStatus),
        default=TaskStatus.PENDING,
        nullable=False
    )
    user_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False
    )
    repository_id: Mapped[int | None] = mapped_column(
        Integer,
        ForeignKey("repositories.id", ondelete="SET NULL")
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        nullable=False
    )

    # Relationships
    user: Mapped["User"] = relationship(back_populates="tasks")
    repository: Mapped["Repository"] = relationship(back_populates="tasks")
    agent_runs: Mapped[list["AgentRun"]] = relationship(
        back_populates="task",
        cascade="all, delete-orphan"
    )
```

### Database Queries
```python
from sqlalchemy import select, and_, or_
from sqlalchemy.orm import selectinload

# Simple query
async def get_tasks(db: AsyncSession, user_id: int) -> list[Task]:
    result = await db.execute(
        select(Task)
        .where(Task.user_id == user_id)
        .order_by(Task.created_at.desc())
    )
    return list(result.scalars().all())

# Query with relationships (eager loading)
async def get_task_with_runs(db: AsyncSession, task_id: int) -> Task | None:
    result = await db.execute(
        select(Task)
        .options(selectinload(Task.agent_runs))
        .where(Task.id == task_id)
    )
    return result.scalar_one_or_none()

# Complex query with filters
async def search_tasks(
    db: AsyncSession,
    user_id: int,
    status: TaskStatus | None = None,
    search: str | None = None
) -> list[Task]:
    query = select(Task).where(Task.user_id == user_id)

    if status:
        query = query.where(Task.status == status)

    if search:
        query = query.where(
            or_(
                Task.title.ilike(f"%{search}%"),
                Task.description.ilike(f"%{search}%")
            )
        )

    result = await db.execute(query)
    return list(result.scalars().all())
```

## LangGraph Agent Patterns

### Agent State Definition
```python
from typing import TypedDict, List, Annotated
from langchain_core.messages import BaseMessage
from langgraph.graph import add_messages

class CodeGraphAgentState(TypedDict):
    """Shared state across all agents."""
    # Task context
    task_id: int
    description: str
    repository_path: str

    # Planning
    plan: List[str]
    current_step: int

    # Execution
    code_changes: List[dict]
    files_modified: List[str]

    # Testing
    test_results: dict
    coverage_percentage: float

    # Messages (automatically managed by LangGraph)
    messages: Annotated[List[BaseMessage], add_messages]

    # Status
    status: str
    error: str | None
```

### Agent Implementation
```python
# agents/planner.py
from langchain_anthropic import ChatAnthropic
from langchain_core.messages import HumanMessage, SystemMessage

from src.agents.base import BaseAgent
from src.core.config import settings

class PlanningAgent(BaseAgent):
    """Agent that breaks down tasks into actionable steps."""

    def __init__(self):
        super().__init__(
            name="planner",
            model_name="claude-sonnet-4-20250514"  # Sonnet 4.5
        )
        self.llm = ChatAnthropic(
            model=self.model_name,
            api_key=settings.ANTHROPIC_API_KEY,
            temperature=0.7
        )

    async def execute(self, state: CodeGraphAgentState) -> CodeGraphAgentState:
        """Create execution plan for the task."""

        system_prompt = """You are a planning agent for CodeGraph.
        Break down the user's coding task into clear, actionable steps.

        Consider:
        - What files need to be created/modified
        - What dependencies are needed
        - What tests should be written
        - Potential edge cases

        Return a numbered list of steps."""

        response = await self.llm.ainvoke([
            SystemMessage(content=system_prompt),
            HumanMessage(content=state["description"])
        ])

        # Parse plan from response
        plan = self._parse_plan(response.content)

        return {
            **state,
            "plan": plan,
            "current_step": 0,
            "status": "planned",
            "messages": [response]
        }

    def _parse_plan(self, content: str) -> List[str]:
        """Extract plan steps from LLM response."""
        lines = content.strip().split("\n")
        steps = []
        for line in lines:
            if line.strip() and (line[0].isdigit() or line.startswith("-")):
                # Remove numbering/bullets
                step = line.lstrip("0123456789.-) ").strip()
                if step:
                    steps.append(step)
        return steps
```

### Workflow Definition
```python
# agents/workflows.py
from langgraph.graph import StateGraph, END

from src.agents.planner import PlanningAgent
from src.agents.coder import CodingAgent
from src.agents.tester import TestingAgent
from src.agents.reviewer import ReviewAgent

def create_coding_workflow():
    """Create the main coding agent workflow."""

    # Initialize agents
    planner = PlanningAgent()
    coder = CodingAgent()
    tester = TestingAgent()
    reviewer = ReviewAgent()

    # Define workflow
    workflow = StateGraph(CodeGraphAgentState)

    # Add nodes
    workflow.add_node("planner", planner.execute)
    workflow.add_node("coder", coder.execute)
    workflow.add_node("tester", tester.execute)
    workflow.add_node("reviewer", reviewer.execute)

    # Define routing logic
    def route_after_planning(state: CodeGraphAgentState) -> str:
        """Decide next step after planning."""
        if state.get("error"):
            return END
        if not state.get("plan"):
            return END
        return "coder"

    def route_after_coding(state: CodeGraphAgentState) -> str:
        """Decide next step after coding."""
        if state.get("error"):
            return END
        if not state.get("code_changes"):
            return END
        return "tester"

    def route_after_testing(state: CodeGraphAgentState) -> str:
        """Decide next step after testing."""
        if state.get("error"):
            return END

        # Check if tests passed
        test_results = state.get("test_results", {})
        if test_results.get("failed", 0) > 0:
            # Tests failed, go back to coder with feedback
            return "coder"

        return "reviewer"

    def route_after_review(state: CodeGraphAgentState) -> str:
        """Decide next step after review."""
        return END

    # Set entry point
    workflow.set_entry_point("planner")

    # Add edges
    workflow.add_conditional_edges("planner", route_after_planning)
    workflow.add_conditional_edges("coder", route_after_coding)
    workflow.add_conditional_edges("tester", route_after_testing)
    workflow.add_conditional_edges("reviewer", route_after_review)

    return workflow.compile()
```

## LangSmith Integration

```python
# core/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # LangSmith
    LANGCHAIN_TRACING_V2: bool = True
    LANGCHAIN_API_KEY: str
    LANGCHAIN_PROJECT: str = "codegraph"

    class Config:
        env_file = ".env"

# agents/base.py
from langsmith import traceable

class BaseAgent:
    @traceable(name="agent_execution")
    async def execute(self, state: dict) -> dict:
        """Execute agent logic with LangSmith tracing."""
        # Automatically traced
        pass
```

## Testing Patterns

### Unit Tests
```python
# tests/unit/test_task_service.py
import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from src.models import Task, User
from src.schemas import TaskCreate
from src.services.task_service import task_service

@pytest.mark.asyncio
async def test_create_task(db_session: AsyncSession, test_user: User):
    """Test creating a new task."""
    task_data = TaskCreate(
        title="Test Task",
        description="Test description",
        repository_id=1
    )

    task = await task_service.create_task(db_session, task_data, test_user.id)

    assert task.id is not None
    assert task.title == "Test Task"
    assert task.user_id == test_user.id
    assert task.status == TaskStatus.PENDING
```

### Integration Tests
```python
# tests/integration/test_api_tasks.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_create_task_endpoint(client: AsyncClient, auth_headers: dict):
    """Test task creation via API."""
    response = await client.post(
        "/api/tasks",
        json={
            "title": "Test Task",
            "description": "Test description",
            "repository_id": 1
        },
        headers=auth_headers
    )

    assert response.status_code == 201
    data = response.json()
    assert data["title"] == "Test Task"
    assert "id" in data
```

### Mocking LLM Calls
```python
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_planning_agent():
    """Test planning agent without calling real API."""
    with patch("langchain_anthropic.ChatAnthropic.ainvoke") as mock_invoke:
        mock_invoke.return_value = AsyncMock(
            content="1. Create file\n2. Add tests\n3. Review"
        )

        agent = PlanningAgent()
        result = await agent.execute({"description": "Add login"})

        assert len(result["plan"]) == 3
        assert "Create file" in result["plan"][0]
```

## Configuration

### Settings Management
```python
# core/config.py
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    # App
    APP_NAME: str = "CodeGraph"
    DEBUG: bool = False

    # Database
    DATABASE_URL: str

    # Redis
    REDIS_URL: str = "redis://localhost:6379"

    # Security
    SECRET_KEY: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # Anthropic
    ANTHROPIC_API_KEY: str

    # GitHub
    GITHUB_TOKEN: str

    # LangSmith
    LANGCHAIN_TRACING_V2: bool = True
    LANGCHAIN_API_KEY: str
    LANGCHAIN_PROJECT: str = "codegraph"

    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    """Cached settings instance."""
    return Settings()

settings = get_settings()
```

## Remember

- **Always use async/await** for I/O operations
- **Type hints are mandatory** on all functions
- **Use Pydantic** for all data validation
- **Service layer** for business logic, not in routes
- **Repository pattern** for database operations
- **LangSmith tracing** on all agent operations
- **Mock external APIs** in tests
- **Structured logging** with context
- **Handle errors gracefully** with custom exceptions
- **Document complex logic** with docstrings