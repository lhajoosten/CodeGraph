# Frontend-Specific Claude Code Instructions

## Context
This is the React frontend for CodeGraph. It provides a modern, intuitive interface for users to interact with AI coding agents, manage tasks, and monitor agent execution in real-time.

## Technology Stack
- **React**: 18.3+
- **TypeScript**: 5.0+ (strict mode)
- **Build Tool**: Vite
- **Routing**: React Router v6
- **State Management**:
  - TanStack Query (React Query) for server state
  - Zustand for client state
- **Forms**: React Hook Form + Zod validation
- **UI Components**: Shadcn/ui + Radix UI primitives
- **Styling**: Tailwind CSS 3.4+
- **Code Editor**: Monaco Editor (VS Code)
- **Testing**: Vitest + React Testing Library
- **Package Manager**: pnpm (preferred) or npm

## Project Structure

```
apps/frontend/
├── public/
│   └── favicon.ico
├── src/
│   ├── main.tsx              # Application entry point
│   ├── App.tsx               # Root component with routing
│   ├── components/           # Reusable components
│   │   ├── ui/              # Shadcn/ui components
│   │   ├── layout/          # Layout components (Header, Sidebar)
│   │   ├── tasks/           # Task-related components
│   │   ├── agents/          # Agent monitoring components
│   │   └── editor/          # Code editor components
│   ├── features/            # Feature-based modules
│   │   ├── auth/           # Authentication flow
│   │   ├── tasks/          # Task management
│   │   ├── agents/         # Agent monitoring
│   │   └── repositories/   # Repository management
│   ├── hooks/              # Custom React hooks
│   │   ├── useAuth.ts
│   │   ├── useTasks.ts
│   │   ├── useAgentStream.ts
│   │   └── useWebSocket.ts
│   ├── lib/                # Utilities and helpers
│   │   ├── api.ts         # API client
│   │   ├── utils.ts       # Utility functions
│   │   └── cn.ts          # Tailwind class merger
│   ├── services/          # API service layer
│   │   ├── api-client.ts  # Base API client
│   │   ├── tasks.ts       # Task API calls
│   │   ├── agents.ts      # Agent API calls
│   │   └── auth.ts        # Auth API calls
│   ├── stores/            # Zustand stores
│   │   ├── auth-store.ts
│   │   └── ui-store.ts
│   ├── types/             # TypeScript types
│   │   ├── api.ts         # API response types
│   │   ├── task.ts        # Task types
│   │   ├── agent.ts       # Agent types
│   │   └── user.ts        # User types
│   └── pages/             # Page components
│       ├── Dashboard.tsx
│       ├── Tasks.tsx
│       ├── TaskDetail.tsx
│       ├── Agents.tsx
│       └── Settings.tsx
├── tests/
│   ├── setup.ts
│   ├── components/
│   └── integration/
├── index.html
├── vite.config.ts
├── tailwind.config.js
├── tsconfig.json
├── package.json
└── README.md
```

## Coding Standards

### Component Structure
```typescript
// Standard component pattern
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Task } from '@/types/task';
import { fetchTask } from '@/services/tasks';

// 1. Props interface
interface TaskCardProps {
  taskId: number;
  onUpdate?: (task: Task) => void;
  className?: string;
}

// 2. Component definition
export function TaskCard({ taskId, onUpdate, className }: TaskCardProps) {
  // 3. Hooks (in order: state, queries, mutations, effects, refs)
  const [isExpanded, setIsExpanded] = useState(false);

  const { data: task, isLoading } = useQuery({
    queryKey: ['task', taskId],
    queryFn: () => fetchTask(taskId),
  });

  // 4. Event handlers
  const handleExpand = () => {
    setIsExpanded(!isExpanded);
  };

  const handleUpdate = () => {
    if (task) {
      onUpdate?.(task);
    }
  };

  // 5. Early returns
  if (isLoading) {
    return ;
  }

  if (!task) {
    return Task not found;
  }

  // 6. Main render
  return (
    <div className={cn('rounded-lg border p-4', className)}>
      {task.title}
      {task.description}

      {isExpanded && (

          {/* Expanded content */}

      )}



          {isExpanded ? 'Collapse' : 'Expand'}

        Update


  );
}

// 7. Helper components (if needed)
function TaskCardSkeleton() {
  return Loading...;
}
```

### Custom Hooks
```typescript
// hooks/useTasks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Task, TaskCreate, TaskUpdate } from '@/types/task';
import { fetchTasks, createTask, updateTask, deleteTask } from '@/services/tasks';

export function useTasks() {
  const queryClient = useQueryClient();

  // Query for all tasks
  const { data: tasks, isLoading, error } = useQuery({
    queryKey: ['tasks'],
    queryFn: fetchTasks,
  });

  // Mutation for creating tasks
  const createMutation = useMutation({
    mutationFn: createTask,
    onSuccess: (newTask) => {
      // Optimistic update
      queryClient.setQueryData(['tasks'], (old) =>
        old ? [...old, newTask] : [newTask]
      );
    },
  });

  // Mutation for updating tasks
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: number; data: TaskUpdate }) =>
      updateTask(id, data),
    onSuccess: (updatedTask) => {
      queryClient.setQueryData(['tasks'], (old) =>
        old?.map((t) => (t.id === updatedTask.id ? updatedTask : t))
      );
    },
  });

  return {
    tasks,
    isLoading,
    error,
    createTask: createMutation.mutate,
    updateTask: updateMutation.mutate,
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
  };
}
```

### Form Handling with React Hook Form + Zod
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

// Define schema
const taskSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200),
  description: z.string().min(10, 'Description must be at least 10 characters'),
  repositoryId: z.number().optional(),
});

type TaskFormData = z.infer;

interface TaskFormProps {
  onSubmit: (data: TaskFormData) => void;
  defaultValues?: Partial;
}

export function TaskForm({ onSubmit, defaultValues }: TaskFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm({
    resolver: zodResolver(taskSchema),
    defaultValues,
  });

  return (



          Title


        {errors.title && (
          {errors.title.message}
        )}




          Description


        {errors.description && (

            {errors.description.message}

        )}



        {isSubmitting ? 'Creating...' : 'Create Task'}


  );
}
```

## State Management

### Server State (TanStack Query)
```typescript
// services/tasks.ts
import { apiClient } from './api-client';
import { Task, TaskCreate, TaskUpdate } from '@/types/task';

export async function fetchTasks(): Promise {
  const response = await apiClient.get('/tasks');
  return response.data;
}

export async function fetchTask(id: number): Promise {
  const response = await apiClient.get(`/tasks/${id}`);
  return response.data;
}

export async function createTask(data: TaskCreate): Promise {
  const response = await apiClient.post('/tasks', data);
  return response.data;
}

// In component:
const { data: task, isLoading } = useQuery({
  queryKey: ['task', taskId],
  queryFn: () => fetchTask(taskId),
  staleTime: 30000, // 30 seconds
  gcTime: 5 * 60 * 1000, // 5 minutes
});
```

### Client State (Zustand)
```typescript
// stores/ui-store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UIState {
  sidebarOpen: boolean;
  theme: 'light' | 'dark';
  toggleSidebar: () => void;
  setTheme: (theme: 'light' | 'dark') => void;
}

export const useUIStore = create()(
  persist(
    (set) => ({
      sidebarOpen: true,
      theme: 'light',
      toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
      setTheme: (theme) => set({ theme }),
    }),
    {
      name: 'ui-storage',
    }
  )
);

// Usage in component:
const { sidebarOpen, toggleSidebar } = useUIStore();
```

## Real-Time Updates (SSE)

```typescript
// hooks/useAgentStream.ts
import { useEffect, useState } from 'react';
import { AgentUpdate } from '@/types/agent';

interface UseAgentStreamOptions {
  taskId: number;
  onUpdate?: (update: AgentUpdate) => void;
}

export function useAgentStream({ taskId, onUpdate }: UseAgentStreamOptions) {
  const [updates, setUpdates] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const eventSource = new EventSource(
      `${import.meta.env.VITE_API_URL}/api/tasks/${taskId}/stream`
    );

    eventSource.onopen = () => {
      setIsConnected(true);
      setError(null);
    };

    eventSource.onmessage = (event) => {
      const update: AgentUpdate = JSON.parse(event.data);
      setUpdates((prev) => [...prev, update]);
      onUpdate?.(update);
    };

    eventSource.onerror = () => {
      setIsConnected(false);
      setError(new Error('Connection lost'));
      eventSource.close();
    };

    return () => {
      eventSource.close();
    };
  }, [taskId, onUpdate]);

  return { updates, isConnected, error };
}

// Usage in component:
export function AgentMonitor({ taskId }: { taskId: number }) {
  const { updates, isConnected } = useAgentStream({ taskId });

  return (




          {isConnected ? 'Connected' : 'Disconnected'}




        {updates.map((update, i) => (

            {update.agent}:{' '}
            {update.message}

        ))}


  );
}
```

## API Client Setup

```typescript
// services/api-client.ts
import axios, { AxiosError } from 'axios';
import { useAuthStore } from '@/stores/auth-store';

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = useAuthStore.getState().token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Token expired, logout user
      useAuthStore.getState().logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

## Styling with Tailwind

### Best Practices
```typescript
import { cn } from '@/lib/utils';

// Good: Use cn() for conditional classes
<div className={cn(
  'rounded-lg border p-4',
  isActive && 'border-primary bg-primary/10',
  isDisabled && 'opacity-50 cursor-not-allowed'
)} />

// Good: Responsive design


// Good: Dark mode support


// Bad: Inline styles

```

### Common Patterns
```typescript
// Card layout

  {/* Content */}


// Button variants (use Shadcn Button component)
import { Button } from '@/components/ui/button';

Primary
Secondary
Tertiary
Delete

// Loading skeleton




```

## Monaco Editor Integration

```typescript
// components/editor/CodeEditor.tsx
import { useRef, useEffect } from 'react';
import Editor, { OnMount } from '@monaco-editor/react';
import type { editor } from 'monaco-editor';

interface CodeEditorProps {
  value: string;
  language: string;
  onChange?: (value: string) => void;
  readOnly?: boolean;
  height?: string;
}

export function CodeEditor({
  value,
  language,
  onChange,
  readOnly = false,
  height = '400px',
}: CodeEditorProps) {
  const editorRef = useRef(null);

  const handleEditorDidMount: OnMount = (editor) => {
    editorRef.current = editor;

    // Configure editor
    editor.updateOptions({
      minimap: { enabled: false },
      fontSize: 14,
      lineNumbers: 'on',
      readOnly,
    });
  };

  const handleChange = (value: string | undefined) => {
    if (value !== undefined) {
      onChange?.(value);
    }
  };

  return (

  );
}
```

## Testing

### Component Tests
```typescript
// tests/components/TaskCard.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { TaskCard } from '@/components/tasks/TaskCard';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: { retry: false },
  },
});

function renderWithProviders(ui: React.ReactElement) {
  return render(

      {ui}

  );
}

describe('TaskCard', () => {
  it('renders task information', async () => {
    renderWithProviders();

    await waitFor(() => {
      expect(screen.getByText('Test Task')).toBeInTheDocument();
    });
  });

  it('calls onUpdate when update button is clicked', async () => {
    const handleUpdate = vi.fn();
    const user = userEvent.setup();

    renderWithProviders(

    );

    const updateButton = await screen.findByRole('button', { name: /update/i });
    await user.click(updateButton);

    expect(handleUpdate).toHaveBeenCalledTimes(1);
  });
});
```

## Performance Optimization

### Code Splitting
```typescript
// App.tsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load pages
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Tasks = lazy(() => import('@/pages/Tasks'));
const TaskDetail = lazy(() => import('@/pages/TaskDetail'));

export function App() {
  return (

      }>

          } />
          } />
          } />



  );
}
```

### Memoization
```typescript
import { useMemo, useCallback } from 'react';

// Memoize expensive computations
const sortedTasks = useMemo(() => {
  return tasks?.sort((a, b) =>
    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );
}, [tasks]);

// Memoize callbacks passed to children
const handleUpdate = useCallback((task: Task) => {
  updateTask({ id: task.id, data: task });
}, [updateTask]);
```

## Environment Variables

```typescript
// vite-env.d.ts
///

interface ImportMetaEnv {
  readonly VITE_API_URL: string;
  readonly VITE_WS_URL: string;
  readonly VITE_APP_NAME: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

// Usage in code:
const apiUrl = import.meta.env.VITE_API_URL;
```

## Remember

- **Functional components only** - no class components
- **Hooks at the top** - never conditionally call hooks
- **Type everything** - use TypeScript strict mode
- **Server state vs client state** - use the right tool
- **Optimize bundle** - lazy load routes and heavy components
- **Accessibility** - use semantic HTML and ARIA labels
- **Responsive design** - mobile-first with Tailwind
- **Error boundaries** - catch errors gracefully
- **Loading states** - always show loading indicators
- **Dark mode** - support both light and dark themes