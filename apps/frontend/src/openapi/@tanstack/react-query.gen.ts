// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import {
  assignUserRoleApiV1AdminUsersUserIdRolePost,
  cancelTaskApiV1TasksTaskIdCancelPost,
  changeEmailApiV1AuthChangeEmailPost,
  changePasswordApiV1AuthChangePasswordPost,
  createTaskApiV1TasksPost,
  createWebhookApiV1WebhooksPost,
  deleteTaskApiV1TasksTaskIdDelete,
  deleteWebhookApiV1WebhooksWebhookIdDelete,
  disableTwoFactorApiV1TwoFactorDisablePost,
  enableTwoFactorApiV1TwoFactorEnablePost,
  estimateMonthlyCostApiV1MetricsEstimatePost,
  executeTaskStreamApiV1TasksTaskIdExecutePost,
  forgotPasswordApiV1AuthForgotPasswordPost,
  getAgentMetricsApiV1MetricsAgentAgentTypeGet,
  getConnectedAccountsOauthAccountsGet,
  getCouncilMetricsApiV1CouncilMetricsGet,
  getCurrentUserInfoApiV1AuthMeGet,
  getCurrentUserInfoApiV1UsersMeGet,
  getExecutionTimelineApiV1TasksTaskIdTimelineGet,
  getGlobalMetricsApiV1MetricsGlobalGet,
  getMetricsHistoryApiV1MetricsHistoryGet,
  getMetricsSummaryApiV1MetricsSummaryGet,
  getOauthProvidersOauthProvidersGet,
  getPricingInfoApiV1MetricsPricingGet,
  getRoleApiV1AdminRolesRoleIdGet,
  getTaskApiV1TasksTaskIdGet,
  getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGet,
  getTaskHistoryApiV1TasksTaskIdHistoryGet,
  getTaskMetricsApiV1MetricsTasksTaskIdGet,
  getTaskResultApiV1TasksTaskIdResultGet,
  getTaskStatusApiV1TasksTaskIdStatusGet,
  getTwoFactorStatusApiV1TwoFactorStatusGet,
  getUserCouncilReviewsApiV1CouncilReviewsGet,
  getUserExecutionHistoryApiV1HistoryGet,
  getUserPermissionsApiV1AdminUsersUserIdPermissionsGet,
  getWebhookApiV1WebhooksWebhookIdGet,
  getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGet,
  healthCheckHealthGet,
  listPermissionsApiV1AdminPermissionsGet,
  listRolesApiV1AdminRolesGet,
  listTasksApiV1TasksGet,
  listUsersWithRolesApiV1AdminUsersGet,
  listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGet,
  listWebhooksApiV1WebhooksGet,
  loginUserApiV1AuthLoginPost,
  logoutApiV1AuthLogoutPost,
  oauthAuthorizeLinkOauthProviderAuthorizeLinkGet,
  oauthAuthorizeOauthProviderAuthorizeGet,
  oauthCallbackOauthProviderCallbackGet,
  type Options,
  refreshApiV1AuthRefreshPost,
  regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPost,
  regenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPost,
  registerUserApiV1AuthRegisterPost,
  removeUserRoleApiV1AdminUsersUserIdRoleDelete,
  resendVerificationApiV1AuthResendVerificationPost,
  resetPasswordApiV1AuthResetPasswordPost,
  sendTestEmailApiV1TestSendTestEmailPost,
  setupTwoFactorApiV1TwoFactorSetupPost,
  testWebhookApiV1WebhooksWebhookIdTestPost,
  unlinkOauthAccountOauthProviderUnlinkDelete,
  updateProfileApiV1AuthProfilePut,
  updateTaskApiV1TasksTaskIdPatch,
  updateWebhookApiV1WebhooksWebhookIdPatch,
  verifyEmailApiV1AuthVerifyEmailPost,
  verifyTwoFactorApiV1TwoFactorVerifyPost,
  verifyTwoFactorLoginApiV1AuthVerify2FaPost,
} from '../sdk.gen';
import type {
  AssignUserRoleApiV1AdminUsersUserIdRolePostData,
  AssignUserRoleApiV1AdminUsersUserIdRolePostError,
  AssignUserRoleApiV1AdminUsersUserIdRolePostResponse,
  CancelTaskApiV1TasksTaskIdCancelPostData,
  CancelTaskApiV1TasksTaskIdCancelPostError,
  CancelTaskApiV1TasksTaskIdCancelPostResponse,
  ChangeEmailApiV1AuthChangeEmailPostData,
  ChangeEmailApiV1AuthChangeEmailPostError,
  ChangeEmailApiV1AuthChangeEmailPostResponse,
  ChangePasswordApiV1AuthChangePasswordPostData,
  ChangePasswordApiV1AuthChangePasswordPostError,
  ChangePasswordApiV1AuthChangePasswordPostResponse,
  CreateTaskApiV1TasksPostData,
  CreateTaskApiV1TasksPostError,
  CreateTaskApiV1TasksPostResponse,
  CreateWebhookApiV1WebhooksPostData,
  CreateWebhookApiV1WebhooksPostError,
  CreateWebhookApiV1WebhooksPostResponse,
  DeleteTaskApiV1TasksTaskIdDeleteData,
  DeleteTaskApiV1TasksTaskIdDeleteError,
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  DeleteWebhookApiV1WebhooksWebhookIdDeleteData,
  DeleteWebhookApiV1WebhooksWebhookIdDeleteError,
  DeleteWebhookApiV1WebhooksWebhookIdDeleteResponse,
  DisableTwoFactorApiV1TwoFactorDisablePostData,
  DisableTwoFactorApiV1TwoFactorDisablePostError,
  DisableTwoFactorApiV1TwoFactorDisablePostResponse,
  EnableTwoFactorApiV1TwoFactorEnablePostData,
  EnableTwoFactorApiV1TwoFactorEnablePostError,
  EnableTwoFactorApiV1TwoFactorEnablePostResponse,
  EstimateMonthlyCostApiV1MetricsEstimatePostData,
  EstimateMonthlyCostApiV1MetricsEstimatePostError,
  EstimateMonthlyCostApiV1MetricsEstimatePostResponse,
  ExecuteTaskStreamApiV1TasksTaskIdExecutePostData,
  ExecuteTaskStreamApiV1TasksTaskIdExecutePostError,
  ForgotPasswordApiV1AuthForgotPasswordPostData,
  ForgotPasswordApiV1AuthForgotPasswordPostError,
  ForgotPasswordApiV1AuthForgotPasswordPostResponse,
  GetAgentMetricsApiV1MetricsAgentAgentTypeGetData,
  GetAgentMetricsApiV1MetricsAgentAgentTypeGetError,
  GetAgentMetricsApiV1MetricsAgentAgentTypeGetResponse,
  GetConnectedAccountsOauthAccountsGetData,
  GetConnectedAccountsOauthAccountsGetError,
  GetConnectedAccountsOauthAccountsGetResponse,
  GetCouncilMetricsApiV1CouncilMetricsGetData,
  GetCouncilMetricsApiV1CouncilMetricsGetError,
  GetCouncilMetricsApiV1CouncilMetricsGetResponse,
  GetCurrentUserInfoApiV1AuthMeGetData,
  GetCurrentUserInfoApiV1AuthMeGetError,
  GetCurrentUserInfoApiV1AuthMeGetResponse,
  GetCurrentUserInfoApiV1UsersMeGetData,
  GetCurrentUserInfoApiV1UsersMeGetError,
  GetCurrentUserInfoApiV1UsersMeGetResponse,
  GetExecutionTimelineApiV1TasksTaskIdTimelineGetData,
  GetExecutionTimelineApiV1TasksTaskIdTimelineGetError,
  GetExecutionTimelineApiV1TasksTaskIdTimelineGetResponse,
  GetGlobalMetricsApiV1MetricsGlobalGetData,
  GetGlobalMetricsApiV1MetricsGlobalGetError,
  GetGlobalMetricsApiV1MetricsGlobalGetResponse,
  GetMetricsHistoryApiV1MetricsHistoryGetData,
  GetMetricsHistoryApiV1MetricsHistoryGetError,
  GetMetricsHistoryApiV1MetricsHistoryGetResponse,
  GetMetricsSummaryApiV1MetricsSummaryGetData,
  GetMetricsSummaryApiV1MetricsSummaryGetError,
  GetMetricsSummaryApiV1MetricsSummaryGetResponse,
  GetOauthProvidersOauthProvidersGetData,
  GetOauthProvidersOauthProvidersGetResponse,
  GetPricingInfoApiV1MetricsPricingGetData,
  GetPricingInfoApiV1MetricsPricingGetError,
  GetPricingInfoApiV1MetricsPricingGetResponse,
  GetRoleApiV1AdminRolesRoleIdGetData,
  GetRoleApiV1AdminRolesRoleIdGetError,
  GetRoleApiV1AdminRolesRoleIdGetResponse,
  GetTaskApiV1TasksTaskIdGetData,
  GetTaskApiV1TasksTaskIdGetError,
  GetTaskApiV1TasksTaskIdGetResponse,
  GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData,
  GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetError,
  GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetResponse,
  GetTaskHistoryApiV1TasksTaskIdHistoryGetData,
  GetTaskHistoryApiV1TasksTaskIdHistoryGetError,
  GetTaskHistoryApiV1TasksTaskIdHistoryGetResponse,
  GetTaskMetricsApiV1MetricsTasksTaskIdGetData,
  GetTaskMetricsApiV1MetricsTasksTaskIdGetError,
  GetTaskMetricsApiV1MetricsTasksTaskIdGetResponse,
  GetTaskResultApiV1TasksTaskIdResultGetData,
  GetTaskResultApiV1TasksTaskIdResultGetError,
  GetTaskResultApiV1TasksTaskIdResultGetResponse,
  GetTaskStatusApiV1TasksTaskIdStatusGetData,
  GetTaskStatusApiV1TasksTaskIdStatusGetError,
  GetTaskStatusApiV1TasksTaskIdStatusGetResponse,
  GetTwoFactorStatusApiV1TwoFactorStatusGetData,
  GetTwoFactorStatusApiV1TwoFactorStatusGetError,
  GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
  GetUserCouncilReviewsApiV1CouncilReviewsGetData,
  GetUserCouncilReviewsApiV1CouncilReviewsGetError,
  GetUserCouncilReviewsApiV1CouncilReviewsGetResponse,
  GetUserExecutionHistoryApiV1HistoryGetData,
  GetUserExecutionHistoryApiV1HistoryGetError,
  GetUserExecutionHistoryApiV1HistoryGetResponse,
  GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetData,
  GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetError,
  GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetResponse,
  GetWebhookApiV1WebhooksWebhookIdGetData,
  GetWebhookApiV1WebhooksWebhookIdGetError,
  GetWebhookApiV1WebhooksWebhookIdGetResponse,
  GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetData,
  GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetError,
  GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetResponse,
  HealthCheckHealthGetData,
  HealthCheckHealthGetResponse,
  ListPermissionsApiV1AdminPermissionsGetData,
  ListPermissionsApiV1AdminPermissionsGetError,
  ListPermissionsApiV1AdminPermissionsGetResponse,
  ListRolesApiV1AdminRolesGetData,
  ListRolesApiV1AdminRolesGetError,
  ListRolesApiV1AdminRolesGetResponse,
  ListTasksApiV1TasksGetData,
  ListTasksApiV1TasksGetError,
  ListTasksApiV1TasksGetResponse,
  ListUsersWithRolesApiV1AdminUsersGetData,
  ListUsersWithRolesApiV1AdminUsersGetError,
  ListUsersWithRolesApiV1AdminUsersGetResponse,
  ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData,
  ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetError,
  ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetResponse,
  ListWebhooksApiV1WebhooksGetData,
  ListWebhooksApiV1WebhooksGetError,
  ListWebhooksApiV1WebhooksGetResponse,
  LoginUserApiV1AuthLoginPostData,
  LoginUserApiV1AuthLoginPostError,
  LoginUserApiV1AuthLoginPostResponse,
  LogoutApiV1AuthLogoutPostData,
  LogoutApiV1AuthLogoutPostError,
  LogoutApiV1AuthLogoutPostResponse,
  OauthAuthorizeLinkOauthProviderAuthorizeLinkGetData,
  OauthAuthorizeLinkOauthProviderAuthorizeLinkGetError,
  OauthAuthorizeOauthProviderAuthorizeGetData,
  OauthAuthorizeOauthProviderAuthorizeGetError,
  OauthCallbackOauthProviderCallbackGetData,
  OauthCallbackOauthProviderCallbackGetError,
  RefreshApiV1AuthRefreshPostData,
  RefreshApiV1AuthRefreshPostError,
  RefreshApiV1AuthRefreshPostResponse,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
  RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostData,
  RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostError,
  RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostResponse,
  RegisterUserApiV1AuthRegisterPostData,
  RegisterUserApiV1AuthRegisterPostError,
  RegisterUserApiV1AuthRegisterPostResponse,
  RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteData,
  RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteError,
  RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteResponse,
  ResendVerificationApiV1AuthResendVerificationPostData,
  ResendVerificationApiV1AuthResendVerificationPostError,
  ResendVerificationApiV1AuthResendVerificationPostResponse,
  ResetPasswordApiV1AuthResetPasswordPostData,
  ResetPasswordApiV1AuthResetPasswordPostError,
  ResetPasswordApiV1AuthResetPasswordPostResponse,
  SendTestEmailApiV1TestSendTestEmailPostData,
  SendTestEmailApiV1TestSendTestEmailPostError,
  SendTestEmailApiV1TestSendTestEmailPostResponse,
  SetupTwoFactorApiV1TwoFactorSetupPostData,
  SetupTwoFactorApiV1TwoFactorSetupPostError,
  SetupTwoFactorApiV1TwoFactorSetupPostResponse,
  TestWebhookApiV1WebhooksWebhookIdTestPostData,
  TestWebhookApiV1WebhooksWebhookIdTestPostError,
  TestWebhookApiV1WebhooksWebhookIdTestPostResponse,
  UnlinkOauthAccountOauthProviderUnlinkDeleteData,
  UnlinkOauthAccountOauthProviderUnlinkDeleteError,
  UnlinkOauthAccountOauthProviderUnlinkDeleteResponse,
  UpdateProfileApiV1AuthProfilePutData,
  UpdateProfileApiV1AuthProfilePutError,
  UpdateProfileApiV1AuthProfilePutResponse,
  UpdateTaskApiV1TasksTaskIdPatchData,
  UpdateTaskApiV1TasksTaskIdPatchError,
  UpdateTaskApiV1TasksTaskIdPatchResponse,
  UpdateWebhookApiV1WebhooksWebhookIdPatchData,
  UpdateWebhookApiV1WebhooksWebhookIdPatchError,
  UpdateWebhookApiV1WebhooksWebhookIdPatchResponse,
  VerifyEmailApiV1AuthVerifyEmailPostData,
  VerifyEmailApiV1AuthVerifyEmailPostError,
  VerifyEmailApiV1AuthVerifyEmailPostResponse,
  VerifyTwoFactorApiV1TwoFactorVerifyPostData,
  VerifyTwoFactorApiV1TwoFactorVerifyPostError,
  VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
  VerifyTwoFactorLoginApiV1AuthVerify2FaPostData,
  VerifyTwoFactorLoginApiV1AuthVerify2FaPostError,
  VerifyTwoFactorLoginApiV1AuthVerify2FaPostResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckHealthGetQueryKey = (options?: Options<HealthCheckHealthGetData>) =>
  createQueryKey('healthCheckHealthGet', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns:
 * Dictionary with status message
 */
export const healthCheckHealthGetOptions = (options?: Options<HealthCheckHealthGetData>) =>
  queryOptions<
    HealthCheckHealthGetResponse,
    AxiosError<DefaultError>,
    HealthCheckHealthGetResponse,
    ReturnType<typeof healthCheckHealthGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options),
  });

/**
 * Register User
 *
 * Register a new user.
 *
 * Args:
 * user_data: User registration data
 * db: Database session
 *
 * Returns:
 * Created user instance
 *
 * Raises:
 * HTTPException: If email already exists
 */
export const registerUserApiV1AuthRegisterPostMutation = (
  options?: Partial<Options<RegisterUserApiV1AuthRegisterPostData>>
): UseMutationOptions<
  RegisterUserApiV1AuthRegisterPostResponse,
  AxiosError<RegisterUserApiV1AuthRegisterPostError>,
  Options<RegisterUserApiV1AuthRegisterPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegisterUserApiV1AuthRegisterPostResponse,
    AxiosError<RegisterUserApiV1AuthRegisterPostError>,
    Options<RegisterUserApiV1AuthRegisterPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await registerUserApiV1AuthRegisterPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login User
 *
 * Authenticate user and return JWT tokens.
 *
 * Args:
 * user_data: User login credentials
 * db: Database session
 *
 * Returns:
 * JWT access and refresh tokens
 *
 * Raises:
 * HTTPException: If credentials are invalid
 */
export const loginUserApiV1AuthLoginPostMutation = (
  options?: Partial<Options<LoginUserApiV1AuthLoginPostData>>
): UseMutationOptions<
  LoginUserApiV1AuthLoginPostResponse,
  AxiosError<LoginUserApiV1AuthLoginPostError>,
  Options<LoginUserApiV1AuthLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LoginUserApiV1AuthLoginPostResponse,
    AxiosError<LoginUserApiV1AuthLoginPostError>,
    Options<LoginUserApiV1AuthLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loginUserApiV1AuthLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Verify Two Factor Login
 *
 * Verify 2FA code during login and issue full tokens.
 *
 * Accepts both partial tokens (traditional 2FA flow) and full tokens (OAuth flow).
 * - Partial token: Used during traditional login's 2FA verification step
 * - Full token: Used during OAuth login where user is already authenticated
 *
 * Args:
 * request_data: Request containing 2FA code and remember_me flag
 * request: FastAPI request object (for IP address)
 * response: FastAPI response object (to set cookies)
 * db: Database session
 * current_user: Current user from partial or full token
 *
 * Returns:
 * LoginResponse: Success message with user data and email verification status
 *
 * Raises:
 * HTTPException: If 2FA code is invalid
 */
export const verifyTwoFactorLoginApiV1AuthVerify2FaPostMutation = (
  options?: Partial<Options<VerifyTwoFactorLoginApiV1AuthVerify2FaPostData>>
): UseMutationOptions<
  VerifyTwoFactorLoginApiV1AuthVerify2FaPostResponse,
  AxiosError<VerifyTwoFactorLoginApiV1AuthVerify2FaPostError>,
  Options<VerifyTwoFactorLoginApiV1AuthVerify2FaPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyTwoFactorLoginApiV1AuthVerify2FaPostResponse,
    AxiosError<VerifyTwoFactorLoginApiV1AuthVerify2FaPostError>,
    Options<VerifyTwoFactorLoginApiV1AuthVerify2FaPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyTwoFactorLoginApiV1AuthVerify2FaPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout
 *
 * Logout user, clears cookies and revokes refresh token.
 *
 * Works even if access token is expired (uses optional authentication).
 *
 * Args:
 * response: FastAPI response object (to clear cookies)
 * refresh_token: Refresh token from cookie
 * current_user: Current authenticated user (if any)
 * db: Database session
 *
 * Returns:
 * dict: Success message
 */
export const logoutApiV1AuthLogoutPostMutation = (
  options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>
): UseMutationOptions<
  LogoutApiV1AuthLogoutPostResponse,
  AxiosError<LogoutApiV1AuthLogoutPostError>,
  Options<LogoutApiV1AuthLogoutPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LogoutApiV1AuthLogoutPostResponse,
    AxiosError<LogoutApiV1AuthLogoutPostError>,
    Options<LogoutApiV1AuthLogoutPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await logoutApiV1AuthLogoutPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Refresh
 *
 * Refresh access token using refresh token from cookie.
 *
 * Implements token rotation: issues new refresh token and revokes old one.
 *
 * Args:
 * response: FastAPI response object (to set new cookies)
 * request: FastAPI request object (for IP address)
 * refresh_token: Refresh token from cookie
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If refresh token is invalid, expired, or revoked
 */
export const refreshApiV1AuthRefreshPostMutation = (
  options?: Partial<Options<RefreshApiV1AuthRefreshPostData>>
): UseMutationOptions<
  RefreshApiV1AuthRefreshPostResponse,
  AxiosError<RefreshApiV1AuthRefreshPostError>,
  Options<RefreshApiV1AuthRefreshPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RefreshApiV1AuthRefreshPostResponse,
    AxiosError<RefreshApiV1AuthRefreshPostError>,
    Options<RefreshApiV1AuthRefreshPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await refreshApiV1AuthRefreshPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1AuthMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1AuthMeGet', options);

/**
 * Get Current User Info
 *
 * Get current authenticated user information.
 *
 * Args:
 * current_user: Current authenticated user
 *
 * Returns:
 * UserResponse: Current user data
 */
export const getCurrentUserInfoApiV1AuthMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    AxiosError<GetCurrentUserInfoApiV1AuthMeGetError>,
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1AuthMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1AuthMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1AuthMeGetQueryKey(options),
  });

/**
 * Verify Email
 *
 * Verify user email with verification token.
 *
 * If 2FA is mandatory and not enabled, issues a partial token for 2FA setup.
 *
 * Args:
 * request_data: Email verification token
 * response: FastAPI response object for setting cookies
 * db: Database session
 *
 * Returns:
 * VerifyEmailResponse: Success message and 2FA setup requirement
 *
 * Raises:
 * HTTPException: If token is invalid or expired
 */
export const verifyEmailApiV1AuthVerifyEmailPostMutation = (
  options?: Partial<Options<VerifyEmailApiV1AuthVerifyEmailPostData>>
): UseMutationOptions<
  VerifyEmailApiV1AuthVerifyEmailPostResponse,
  AxiosError<VerifyEmailApiV1AuthVerifyEmailPostError>,
  Options<VerifyEmailApiV1AuthVerifyEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyEmailApiV1AuthVerifyEmailPostResponse,
    AxiosError<VerifyEmailApiV1AuthVerifyEmailPostError>,
    Options<VerifyEmailApiV1AuthVerifyEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyEmailApiV1AuthVerifyEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Resend Verification
 *
 * Resend verification email to user.
 *
 * Args:
 * request_data: User email address
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If email not found
 */
export const resendVerificationApiV1AuthResendVerificationPostMutation = (
  options?: Partial<Options<ResendVerificationApiV1AuthResendVerificationPostData>>
): UseMutationOptions<
  ResendVerificationApiV1AuthResendVerificationPostResponse,
  AxiosError<ResendVerificationApiV1AuthResendVerificationPostError>,
  Options<ResendVerificationApiV1AuthResendVerificationPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ResendVerificationApiV1AuthResendVerificationPostResponse,
    AxiosError<ResendVerificationApiV1AuthResendVerificationPostError>,
    Options<ResendVerificationApiV1AuthResendVerificationPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await resendVerificationApiV1AuthResendVerificationPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Forgot Password
 *
 * Request password reset for user account.
 *
 * Args:
 * request_data: User email address
 * db: Database session
 *
 * Returns:
 * dict: Success message (always returns success for security)
 */
export const forgotPasswordApiV1AuthForgotPasswordPostMutation = (
  options?: Partial<Options<ForgotPasswordApiV1AuthForgotPasswordPostData>>
): UseMutationOptions<
  ForgotPasswordApiV1AuthForgotPasswordPostResponse,
  AxiosError<ForgotPasswordApiV1AuthForgotPasswordPostError>,
  Options<ForgotPasswordApiV1AuthForgotPasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ForgotPasswordApiV1AuthForgotPasswordPostResponse,
    AxiosError<ForgotPasswordApiV1AuthForgotPasswordPostError>,
    Options<ForgotPasswordApiV1AuthForgotPasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await forgotPasswordApiV1AuthForgotPasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reset Password
 *
 * Reset user password with reset token.
 *
 * Args:
 * request_data: Reset token and new password
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If token is invalid or expired
 */
export const resetPasswordApiV1AuthResetPasswordPostMutation = (
  options?: Partial<Options<ResetPasswordApiV1AuthResetPasswordPostData>>
): UseMutationOptions<
  ResetPasswordApiV1AuthResetPasswordPostResponse,
  AxiosError<ResetPasswordApiV1AuthResetPasswordPostError>,
  Options<ResetPasswordApiV1AuthResetPasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ResetPasswordApiV1AuthResetPasswordPostResponse,
    AxiosError<ResetPasswordApiV1AuthResetPasswordPostError>,
    Options<ResetPasswordApiV1AuthResetPasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await resetPasswordApiV1AuthResetPasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Change Password
 *
 * Change password for authenticated user.
 *
 * Args:
 * request_data: Current password and new password
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If current password is incorrect
 */
export const changePasswordApiV1AuthChangePasswordPostMutation = (
  options?: Partial<Options<ChangePasswordApiV1AuthChangePasswordPostData>>
): UseMutationOptions<
  ChangePasswordApiV1AuthChangePasswordPostResponse,
  AxiosError<ChangePasswordApiV1AuthChangePasswordPostError>,
  Options<ChangePasswordApiV1AuthChangePasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangePasswordApiV1AuthChangePasswordPostResponse,
    AxiosError<ChangePasswordApiV1AuthChangePasswordPostError>,
    Options<ChangePasswordApiV1AuthChangePasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await changePasswordApiV1AuthChangePasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Change Email
 *
 * Request email change for authenticated user.
 *
 * Sends verification email to new address.
 *
 * Args:
 * request_data: New email address and password
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If password is incorrect or new email already registered
 */
export const changeEmailApiV1AuthChangeEmailPostMutation = (
  options?: Partial<Options<ChangeEmailApiV1AuthChangeEmailPostData>>
): UseMutationOptions<
  ChangeEmailApiV1AuthChangeEmailPostResponse,
  AxiosError<ChangeEmailApiV1AuthChangeEmailPostError>,
  Options<ChangeEmailApiV1AuthChangeEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangeEmailApiV1AuthChangeEmailPostResponse,
    AxiosError<ChangeEmailApiV1AuthChangeEmailPostError>,
    Options<ChangeEmailApiV1AuthChangeEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await changeEmailApiV1AuthChangeEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Profile
 *
 * Update user profile information.
 *
 * Args:
 * profile_data: Profile fields to update
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * UserResponse: Updated user data
 *
 * Raises:
 * HTTPException: If update fails
 */
export const updateProfileApiV1AuthProfilePutMutation = (
  options?: Partial<Options<UpdateProfileApiV1AuthProfilePutData>>
): UseMutationOptions<
  UpdateProfileApiV1AuthProfilePutResponse,
  AxiosError<UpdateProfileApiV1AuthProfilePutError>,
  Options<UpdateProfileApiV1AuthProfilePutData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProfileApiV1AuthProfilePutResponse,
    AxiosError<UpdateProfileApiV1AuthProfilePutError>,
    Options<UpdateProfileApiV1AuthProfilePutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateProfileApiV1AuthProfilePut({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1UsersMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1UsersMeGet', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Requires a full access token. Rejects partial tokens (2FA verification step).
 *
 * Args:
 * current_user: Current authenticated user (requires full token)
 *
 * Returns:
 * Current user data
 */
export const getCurrentUserInfoApiV1UsersMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    AxiosError<GetCurrentUserInfoApiV1UsersMeGetError>,
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1UsersMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1UsersMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1UsersMeGetQueryKey(options),
  });

export const listTasksApiV1TasksGetQueryKey = (options?: Options<ListTasksApiV1TasksGetData>) =>
  createQueryKey('listTasksApiV1TasksGet', options);

/**
 * List Tasks
 *
 * List tasks with pagination.
 *
 * Requires: task:read permission
 *
 * - Admins and superusers see all tasks
 * - Other users see only their own tasks
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user with task:read permission
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetOptions = (options?: Options<ListTasksApiV1TasksGetData>) =>
  queryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    ListTasksApiV1TasksGetResponse,
    ReturnType<typeof listTasksApiV1TasksGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTasksApiV1TasksGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listTasksApiV1TasksGetQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listTasksApiV1TasksGetInfiniteQueryKey = (
  options?: Options<ListTasksApiV1TasksGetData>
): QueryKey<Options<ListTasksApiV1TasksGetData>> =>
  createQueryKey('listTasksApiV1TasksGet', options, true);

/**
 * List Tasks
 *
 * List tasks with pagination.
 *
 * Requires: task:read permission
 *
 * - Admins and superusers see all tasks
 * - Other users see only their own tasks
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user with task:read permission
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetInfiniteOptions = (
  options?: Options<ListTasksApiV1TasksGetData>
) =>
  infiniteQueryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    InfiniteData<ListTasksApiV1TasksGetResponse>,
    QueryKey<Options<ListTasksApiV1TasksGetData>>,
    | number
    | Pick<QueryKey<Options<ListTasksApiV1TasksGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListTasksApiV1TasksGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTasksApiV1TasksGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listTasksApiV1TasksGetInfiniteQueryKey(options),
    }
  );

/**
 * Create Task
 *
 * Create a new coding task.
 *
 * Requires: task:create permission
 *
 * Args:
 * task_data: Task creation data
 * db: Database session
 * current_user: Current authenticated user with task:create permission
 *
 * Returns:
 * Created task instance
 */
export const createTaskApiV1TasksPostMutation = (
  options?: Partial<Options<CreateTaskApiV1TasksPostData>>
): UseMutationOptions<
  CreateTaskApiV1TasksPostResponse,
  AxiosError<CreateTaskApiV1TasksPostError>,
  Options<CreateTaskApiV1TasksPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTaskApiV1TasksPostResponse,
    AxiosError<CreateTaskApiV1TasksPostError>,
    Options<CreateTaskApiV1TasksPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createTaskApiV1TasksPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Task
 *
 * Delete a task.
 *
 * Requires: Ownership of the task, or admin/superuser access
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user (ownership verified by dependency)
 *
 * Raises:
 * HTTPException: If task not found
 */
export const deleteTaskApiV1TasksTaskIdDeleteMutation = (
  options?: Partial<Options<DeleteTaskApiV1TasksTaskIdDeleteData>>
): UseMutationOptions<
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
  Options<DeleteTaskApiV1TasksTaskIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTaskApiV1TasksTaskIdDeleteResponse,
    AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
    Options<DeleteTaskApiV1TasksTaskIdDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteTaskApiV1TasksTaskIdDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTaskApiV1TasksTaskIdGetQueryKey = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) => createQueryKey('getTaskApiV1TasksTaskIdGet', options);

/**
 * Get Task
 *
 * Get a specific task by ID.
 *
 * Requires: Ownership of the task, or admin/superuser access
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user (ownership verified by dependency)
 *
 * Returns:
 * Task instance
 *
 * Raises:
 * HTTPException: If task not found
 */
export const getTaskApiV1TasksTaskIdGetOptions = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) =>
  queryOptions<
    GetTaskApiV1TasksTaskIdGetResponse,
    AxiosError<GetTaskApiV1TasksTaskIdGetError>,
    GetTaskApiV1TasksTaskIdGetResponse,
    ReturnType<typeof getTaskApiV1TasksTaskIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskApiV1TasksTaskIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskApiV1TasksTaskIdGetQueryKey(options),
  });

/**
 * Update Task
 *
 * Update a task.
 *
 * Requires: Ownership of the task, or admin/superuser access
 *
 * Args:
 * task_id: Task ID
 * task_data: Task update data
 * db: Database session
 * current_user: Current authenticated user (ownership verified by dependency)
 *
 * Returns:
 * Updated task instance
 *
 * Raises:
 * HTTPException: If task not found
 */
export const updateTaskApiV1TasksTaskIdPatchMutation = (
  options?: Partial<Options<UpdateTaskApiV1TasksTaskIdPatchData>>
): UseMutationOptions<
  UpdateTaskApiV1TasksTaskIdPatchResponse,
  AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
  Options<UpdateTaskApiV1TasksTaskIdPatchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTaskApiV1TasksTaskIdPatchResponse,
    AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
    Options<UpdateTaskApiV1TasksTaskIdPatchData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateTaskApiV1TasksTaskIdPatch({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Execute Task Stream
 *
 * Execute a coding task with real-time streaming output.
 *
 * Streams the complete execution of the multi-agent workflow, including
 * real-time updates from planning, coding, testing, and review stages.
 * Uses Server-Sent Events (SSE) for efficient streaming to the client.
 *
 * Args:
 * task_id: ID of the task to execute
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * StreamingResponse with SSE formatted events
 *
 * Raises:
 * HTTPException: If task not found or user lacks permission
 *
 * Query Parameters:
 * thread_id: Optional thread ID for resuming previous execution
 *
 * Example:
 * GET /api/v1/agents/tasks/123/execute
 *
 * Returns streaming events like:
 * data: {"type": "node_start", "node": "planner"}
 *
 *
 * data: {"type": "token", "content": "Step 1: "}
 *
 *
 * data: {"type": "node_end", "node": "planner", "duration": 2.5}
 *
 *
 *
 * Note:
 * Error recovery is handled automatically by the workflow layer via
 * resilient node wrappers that provide retry logic with exponential backoff.
 */
export const executeTaskStreamApiV1TasksTaskIdExecutePostMutation = (
  options?: Partial<Options<ExecuteTaskStreamApiV1TasksTaskIdExecutePostData>>
): UseMutationOptions<
  unknown,
  AxiosError<ExecuteTaskStreamApiV1TasksTaskIdExecutePostError>,
  Options<ExecuteTaskStreamApiV1TasksTaskIdExecutePostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<ExecuteTaskStreamApiV1TasksTaskIdExecutePostError>,
    Options<ExecuteTaskStreamApiV1TasksTaskIdExecutePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await executeTaskStreamApiV1TasksTaskIdExecutePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTaskStatusApiV1TasksTaskIdStatusGetQueryKey = (
  options: Options<GetTaskStatusApiV1TasksTaskIdStatusGetData>
) => createQueryKey('getTaskStatusApiV1TasksTaskIdStatusGet', options);

/**
 * Get Task Status
 *
 * Get current status of a task execution.
 *
 * Returns the latest execution state including current node, progress,
 * and any errors encountered.
 *
 * Args:
 * task_id: ID of the task
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Task status object with current state and progress
 *
 * Raises:
 * HTTPException: If task not found
 */
export const getTaskStatusApiV1TasksTaskIdStatusGetOptions = (
  options: Options<GetTaskStatusApiV1TasksTaskIdStatusGetData>
) =>
  queryOptions<
    GetTaskStatusApiV1TasksTaskIdStatusGetResponse,
    AxiosError<GetTaskStatusApiV1TasksTaskIdStatusGetError>,
    GetTaskStatusApiV1TasksTaskIdStatusGetResponse,
    ReturnType<typeof getTaskStatusApiV1TasksTaskIdStatusGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskStatusApiV1TasksTaskIdStatusGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskStatusApiV1TasksTaskIdStatusGetQueryKey(options),
  });

/**
 * Cancel Task
 *
 * Cancel an ongoing task execution.
 *
 * Signals the workflow to stop and cleanup resources. The cancellation
 * is graceful - nodes will complete their current operation before stopping.
 *
 * Args:
 * task_id: ID of the task to cancel
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Confirmation with cancellation status
 *
 * Raises:
 * HTTPException: If task not found
 */
export const cancelTaskApiV1TasksTaskIdCancelPostMutation = (
  options?: Partial<Options<CancelTaskApiV1TasksTaskIdCancelPostData>>
): UseMutationOptions<
  CancelTaskApiV1TasksTaskIdCancelPostResponse,
  AxiosError<CancelTaskApiV1TasksTaskIdCancelPostError>,
  Options<CancelTaskApiV1TasksTaskIdCancelPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CancelTaskApiV1TasksTaskIdCancelPostResponse,
    AxiosError<CancelTaskApiV1TasksTaskIdCancelPostError>,
    Options<CancelTaskApiV1TasksTaskIdCancelPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await cancelTaskApiV1TasksTaskIdCancelPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTaskResultApiV1TasksTaskIdResultGetQueryKey = (
  options: Options<GetTaskResultApiV1TasksTaskIdResultGetData>
) => createQueryKey('getTaskResultApiV1TasksTaskIdResultGet', options);

/**
 * Get Task Result
 *
 * Get final result of completed task execution.
 *
 * Returns the complete output from all workflow stages including plan,
 * generated code, test results, and review feedback.
 *
 * Args:
 * task_id: ID of the completed task
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Complete task execution result
 *
 * Raises:
 * HTTPException: If task not found or still executing
 */
export const getTaskResultApiV1TasksTaskIdResultGetOptions = (
  options: Options<GetTaskResultApiV1TasksTaskIdResultGetData>
) =>
  queryOptions<
    GetTaskResultApiV1TasksTaskIdResultGetResponse,
    AxiosError<GetTaskResultApiV1TasksTaskIdResultGetError>,
    GetTaskResultApiV1TasksTaskIdResultGetResponse,
    ReturnType<typeof getTaskResultApiV1TasksTaskIdResultGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskResultApiV1TasksTaskIdResultGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskResultApiV1TasksTaskIdResultGetQueryKey(options),
  });

export const getTaskHistoryApiV1TasksTaskIdHistoryGetQueryKey = (
  options: Options<GetTaskHistoryApiV1TasksTaskIdHistoryGetData>
) => createQueryKey('getTaskHistoryApiV1TasksTaskIdHistoryGet', options);

/**
 * Get Task History
 *
 * Get complete execution history for a task.
 *
 * Returns a comprehensive view of all agent runs, including timing,
 * tokens, costs, and optionally council review data.
 *
 * Args:
 * task_id: ID of the task
 * include_council: Whether to include council review details (default True)
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Complete task execution history with all agent runs and metrics
 *
 * Raises:
 * HTTPException: If task not found or user lacks permission
 */
export const getTaskHistoryApiV1TasksTaskIdHistoryGetOptions = (
  options: Options<GetTaskHistoryApiV1TasksTaskIdHistoryGetData>
) =>
  queryOptions<
    GetTaskHistoryApiV1TasksTaskIdHistoryGetResponse,
    AxiosError<GetTaskHistoryApiV1TasksTaskIdHistoryGetError>,
    GetTaskHistoryApiV1TasksTaskIdHistoryGetResponse,
    ReturnType<typeof getTaskHistoryApiV1TasksTaskIdHistoryGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskHistoryApiV1TasksTaskIdHistoryGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskHistoryApiV1TasksTaskIdHistoryGetQueryKey(options),
  });

export const getUserExecutionHistoryApiV1HistoryGetQueryKey = (
  options?: Options<GetUserExecutionHistoryApiV1HistoryGetData>
) => createQueryKey('getUserExecutionHistoryApiV1HistoryGet', options);

/**
 * Get User Execution History
 *
 * Get paginated execution history for the current user.
 *
 * Returns a list of all tasks with their execution summary,
 * supporting filtering by status and date range.
 *
 * Args:
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * status: Optional filter by task status
 * date_from: Optional start date filter
 * date_to: Optional end date filter
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of task execution summaries
 */
export const getUserExecutionHistoryApiV1HistoryGetOptions = (
  options?: Options<GetUserExecutionHistoryApiV1HistoryGetData>
) =>
  queryOptions<
    GetUserExecutionHistoryApiV1HistoryGetResponse,
    AxiosError<GetUserExecutionHistoryApiV1HistoryGetError>,
    GetUserExecutionHistoryApiV1HistoryGetResponse,
    ReturnType<typeof getUserExecutionHistoryApiV1HistoryGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserExecutionHistoryApiV1HistoryGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserExecutionHistoryApiV1HistoryGetQueryKey(options),
  });

export const getUserExecutionHistoryApiV1HistoryGetInfiniteQueryKey = (
  options?: Options<GetUserExecutionHistoryApiV1HistoryGetData>
): QueryKey<Options<GetUserExecutionHistoryApiV1HistoryGetData>> =>
  createQueryKey('getUserExecutionHistoryApiV1HistoryGet', options, true);

/**
 * Get User Execution History
 *
 * Get paginated execution history for the current user.
 *
 * Returns a list of all tasks with their execution summary,
 * supporting filtering by status and date range.
 *
 * Args:
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * status: Optional filter by task status
 * date_from: Optional start date filter
 * date_to: Optional end date filter
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of task execution summaries
 */
export const getUserExecutionHistoryApiV1HistoryGetInfiniteOptions = (
  options?: Options<GetUserExecutionHistoryApiV1HistoryGetData>
) =>
  infiniteQueryOptions<
    GetUserExecutionHistoryApiV1HistoryGetResponse,
    AxiosError<GetUserExecutionHistoryApiV1HistoryGetError>,
    InfiniteData<GetUserExecutionHistoryApiV1HistoryGetResponse>,
    QueryKey<Options<GetUserExecutionHistoryApiV1HistoryGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetUserExecutionHistoryApiV1HistoryGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserExecutionHistoryApiV1HistoryGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserExecutionHistoryApiV1HistoryGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserExecutionHistoryApiV1HistoryGetInfiniteQueryKey(options),
    }
  );

export const getExecutionTimelineApiV1TasksTaskIdTimelineGetQueryKey = (
  options: Options<GetExecutionTimelineApiV1TasksTaskIdTimelineGetData>
) => createQueryKey('getExecutionTimelineApiV1TasksTaskIdTimelineGet', options);

/**
 * Get Execution Timeline
 *
 * Get detailed execution timeline for visualization.
 *
 * Returns a chronological list of all events during task execution,
 * suitable for timeline visualization in the frontend.
 *
 * Args:
 * task_id: ID of the task
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * List of timeline events with timestamps and event data
 *
 * Raises:
 * HTTPException: If task not found or user lacks permission
 */
export const getExecutionTimelineApiV1TasksTaskIdTimelineGetOptions = (
  options: Options<GetExecutionTimelineApiV1TasksTaskIdTimelineGetData>
) =>
  queryOptions<
    GetExecutionTimelineApiV1TasksTaskIdTimelineGetResponse,
    AxiosError<GetExecutionTimelineApiV1TasksTaskIdTimelineGetError>,
    GetExecutionTimelineApiV1TasksTaskIdTimelineGetResponse,
    ReturnType<typeof getExecutionTimelineApiV1TasksTaskIdTimelineGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getExecutionTimelineApiV1TasksTaskIdTimelineGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getExecutionTimelineApiV1TasksTaskIdTimelineGetQueryKey(options),
  });

export const getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetQueryKey = (
  options: Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>
) => createQueryKey('getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGet', options);

/**
 * Get Task Council Reviews
 *
 * Get council review history for a specific task.
 *
 * Returns paginated list of all council reviews for the task,
 * including verdict, consensus type, and judge count.
 *
 * Args:
 * task_id: ID of the task
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of council reviews
 *
 * Raises:
 * HTTPException: If task not found or user lacks permission
 */
export const getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetOptions = (
  options: Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>
) =>
  queryOptions<
    GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetResponse,
    AxiosError<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetError>,
    GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetResponse,
    ReturnType<typeof getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetQueryKey(options),
  });

export const getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetInfiniteQueryKey = (
  options: Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>
): QueryKey<Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>> =>
  createQueryKey('getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGet', options, true);

/**
 * Get Task Council Reviews
 *
 * Get council review history for a specific task.
 *
 * Returns paginated list of all council reviews for the task,
 * including verdict, consensus type, and judge count.
 *
 * Args:
 * task_id: ID of the task
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of council reviews
 *
 * Raises:
 * HTTPException: If task not found or user lacks permission
 */
export const getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetInfiniteOptions = (
  options: Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>
) =>
  infiniteQueryOptions<
    GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetResponse,
    AxiosError<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetError>,
    InfiniteData<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetResponse>,
    QueryKey<Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTaskCouncilReviewsApiV1TasksTaskIdCouncilReviewsGetInfiniteQueryKey(options),
    }
  );

export const getUserCouncilReviewsApiV1CouncilReviewsGetQueryKey = (
  options?: Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>
) => createQueryKey('getUserCouncilReviewsApiV1CouncilReviewsGet', options);

/**
 * Get User Council Reviews
 *
 * Get all council reviews for the current user's tasks.
 *
 * Returns paginated list of all council reviews across all user's tasks,
 * useful for analytics and history views.
 *
 * Args:
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of council reviews
 */
export const getUserCouncilReviewsApiV1CouncilReviewsGetOptions = (
  options?: Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>
) =>
  queryOptions<
    GetUserCouncilReviewsApiV1CouncilReviewsGetResponse,
    AxiosError<GetUserCouncilReviewsApiV1CouncilReviewsGetError>,
    GetUserCouncilReviewsApiV1CouncilReviewsGetResponse,
    ReturnType<typeof getUserCouncilReviewsApiV1CouncilReviewsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserCouncilReviewsApiV1CouncilReviewsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserCouncilReviewsApiV1CouncilReviewsGetQueryKey(options),
  });

export const getUserCouncilReviewsApiV1CouncilReviewsGetInfiniteQueryKey = (
  options?: Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>
): QueryKey<Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>> =>
  createQueryKey('getUserCouncilReviewsApiV1CouncilReviewsGet', options, true);

/**
 * Get User Council Reviews
 *
 * Get all council reviews for the current user's tasks.
 *
 * Returns paginated list of all council reviews across all user's tasks,
 * useful for analytics and history views.
 *
 * Args:
 * page: Page number (1-indexed)
 * page_size: Number of items per page (max 100)
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Paginated list of council reviews
 */
export const getUserCouncilReviewsApiV1CouncilReviewsGetInfiniteOptions = (
  options?: Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>
) =>
  infiniteQueryOptions<
    GetUserCouncilReviewsApiV1CouncilReviewsGetResponse,
    AxiosError<GetUserCouncilReviewsApiV1CouncilReviewsGetError>,
    InfiniteData<GetUserCouncilReviewsApiV1CouncilReviewsGetResponse>,
    QueryKey<Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserCouncilReviewsApiV1CouncilReviewsGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserCouncilReviewsApiV1CouncilReviewsGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserCouncilReviewsApiV1CouncilReviewsGetInfiniteQueryKey(options),
    }
  );

export const getCouncilMetricsApiV1CouncilMetricsGetQueryKey = (
  options?: Options<GetCouncilMetricsApiV1CouncilMetricsGetData>
) => createQueryKey('getCouncilMetricsApiV1CouncilMetricsGet', options);

/**
 * Get Council Metrics
 *
 * Get aggregate metrics for council reviews.
 *
 * Returns comprehensive metrics including verdict distribution,
 * consensus breakdown, and per-judge performance statistics.
 *
 * Args:
 * date_from: Optional start date filter
 * date_to: Optional end date filter
 * db: Database session
 * current_user: Authenticated user
 *
 * Returns:
 * Aggregate council review metrics
 */
export const getCouncilMetricsApiV1CouncilMetricsGetOptions = (
  options?: Options<GetCouncilMetricsApiV1CouncilMetricsGetData>
) =>
  queryOptions<
    GetCouncilMetricsApiV1CouncilMetricsGetResponse,
    AxiosError<GetCouncilMetricsApiV1CouncilMetricsGetError>,
    GetCouncilMetricsApiV1CouncilMetricsGetResponse,
    ReturnType<typeof getCouncilMetricsApiV1CouncilMetricsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCouncilMetricsApiV1CouncilMetricsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCouncilMetricsApiV1CouncilMetricsGetQueryKey(options),
  });

export const getMetricsSummaryApiV1MetricsSummaryGetQueryKey = (
  options?: Options<GetMetricsSummaryApiV1MetricsSummaryGetData>
) => createQueryKey('getMetricsSummaryApiV1MetricsSummaryGet', options);

/**
 * Get Metrics Summary
 *
 * Get high-level metrics summary for dashboard display.
 *
 * Returns aggregated token usage, cost calculations, and per-agent breakdown
 * for the specified time period.
 *
 * Args:
 * period: Time period (24h, 7d, 30d, or all)
 *
 * Returns:
 * MetricsSummaryResponse with tokens, costs, and breakdowns
 */
export const getMetricsSummaryApiV1MetricsSummaryGetOptions = (
  options?: Options<GetMetricsSummaryApiV1MetricsSummaryGetData>
) =>
  queryOptions<
    GetMetricsSummaryApiV1MetricsSummaryGetResponse,
    AxiosError<GetMetricsSummaryApiV1MetricsSummaryGetError>,
    GetMetricsSummaryApiV1MetricsSummaryGetResponse,
    ReturnType<typeof getMetricsSummaryApiV1MetricsSummaryGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMetricsSummaryApiV1MetricsSummaryGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMetricsSummaryApiV1MetricsSummaryGetQueryKey(options),
  });

export const getTaskMetricsApiV1MetricsTasksTaskIdGetQueryKey = (
  options: Options<GetTaskMetricsApiV1MetricsTasksTaskIdGetData>
) => createQueryKey('getTaskMetricsApiV1MetricsTasksTaskIdGet', options);

/**
 * Get Task Metrics
 *
 * Get metrics for a specific task.
 *
 * Returns detailed token usage and cost breakdown for a single task,
 * including per-agent metrics.
 *
 * Args:
 * task_id: ID of the task
 *
 * Returns:
 * TaskMetricsResponse with task-specific metrics
 */
export const getTaskMetricsApiV1MetricsTasksTaskIdGetOptions = (
  options: Options<GetTaskMetricsApiV1MetricsTasksTaskIdGetData>
) =>
  queryOptions<
    GetTaskMetricsApiV1MetricsTasksTaskIdGetResponse,
    AxiosError<GetTaskMetricsApiV1MetricsTasksTaskIdGetError>,
    GetTaskMetricsApiV1MetricsTasksTaskIdGetResponse,
    ReturnType<typeof getTaskMetricsApiV1MetricsTasksTaskIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskMetricsApiV1MetricsTasksTaskIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskMetricsApiV1MetricsTasksTaskIdGetQueryKey(options),
  });

export const getMetricsHistoryApiV1MetricsHistoryGetQueryKey = (
  options?: Options<GetMetricsHistoryApiV1MetricsHistoryGetData>
) => createQueryKey('getMetricsHistoryApiV1MetricsHistoryGet', options);

/**
 * Get Metrics History
 *
 * Get time-series metrics data for charting.
 *
 * Returns bucketed metrics data suitable for time-series charts,
 * with configurable period and interval.
 *
 * Args:
 * period: Time period (24h, 7d, 30d)
 * interval: Bucket interval (1h, 6h, 1d)
 *
 * Returns:
 * MetricsTimeseriesResponse with data points
 */
export const getMetricsHistoryApiV1MetricsHistoryGetOptions = (
  options?: Options<GetMetricsHistoryApiV1MetricsHistoryGetData>
) =>
  queryOptions<
    GetMetricsHistoryApiV1MetricsHistoryGetResponse,
    AxiosError<GetMetricsHistoryApiV1MetricsHistoryGetError>,
    GetMetricsHistoryApiV1MetricsHistoryGetResponse,
    ReturnType<typeof getMetricsHistoryApiV1MetricsHistoryGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMetricsHistoryApiV1MetricsHistoryGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMetricsHistoryApiV1MetricsHistoryGetQueryKey(options),
  });

export const getAgentMetricsApiV1MetricsAgentAgentTypeGetQueryKey = (
  options: Options<GetAgentMetricsApiV1MetricsAgentAgentTypeGetData>
) => createQueryKey('getAgentMetricsApiV1MetricsAgentAgentTypeGet', options);

/**
 * Get Agent Metrics
 *
 * Get metrics for a specific agent type.
 *
 * Returns detailed metrics for a single agent type (planner, coder,
 * tester, or reviewer).
 *
 * Args:
 * agent_type: Type of agent (PLANNER, CODER, TESTER, REVIEWER)
 * period: Time period (24h, 7d, 30d, or all)
 *
 * Returns:
 * AgentMetricsResponse with agent-specific metrics
 */
export const getAgentMetricsApiV1MetricsAgentAgentTypeGetOptions = (
  options: Options<GetAgentMetricsApiV1MetricsAgentAgentTypeGetData>
) =>
  queryOptions<
    GetAgentMetricsApiV1MetricsAgentAgentTypeGetResponse,
    AxiosError<GetAgentMetricsApiV1MetricsAgentAgentTypeGetError>,
    GetAgentMetricsApiV1MetricsAgentAgentTypeGetResponse,
    ReturnType<typeof getAgentMetricsApiV1MetricsAgentAgentTypeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAgentMetricsApiV1MetricsAgentAgentTypeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAgentMetricsApiV1MetricsAgentAgentTypeGetQueryKey(options),
  });

export const getPricingInfoApiV1MetricsPricingGetQueryKey = (
  options?: Options<GetPricingInfoApiV1MetricsPricingGetData>
) => createQueryKey('getPricingInfoApiV1MetricsPricingGet', options);

/**
 * Get Pricing Info
 *
 * Get current LLM pricing information.
 *
 * Returns the pricing per 1M tokens for each supported model,
 * useful for displaying cost context to users.
 *
 * Returns:
 * PricingInfoResponse with model pricing
 */
export const getPricingInfoApiV1MetricsPricingGetOptions = (
  options?: Options<GetPricingInfoApiV1MetricsPricingGetData>
) =>
  queryOptions<
    GetPricingInfoApiV1MetricsPricingGetResponse,
    AxiosError<GetPricingInfoApiV1MetricsPricingGetError>,
    GetPricingInfoApiV1MetricsPricingGetResponse,
    ReturnType<typeof getPricingInfoApiV1MetricsPricingGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPricingInfoApiV1MetricsPricingGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPricingInfoApiV1MetricsPricingGetQueryKey(options),
  });

/**
 * Estimate Monthly Cost
 *
 * Estimate monthly costs based on daily token usage.
 *
 * Calculates what the monthly cost would be if using cloud LLMs
 * instead of local vLLM, based on projected daily usage.
 *
 * Args:
 * request: Daily token estimate and input ratio
 *
 * Returns:
 * MonthlyEstimateResponse with cost projections
 */
export const estimateMonthlyCostApiV1MetricsEstimatePostMutation = (
  options?: Partial<Options<EstimateMonthlyCostApiV1MetricsEstimatePostData>>
): UseMutationOptions<
  EstimateMonthlyCostApiV1MetricsEstimatePostResponse,
  AxiosError<EstimateMonthlyCostApiV1MetricsEstimatePostError>,
  Options<EstimateMonthlyCostApiV1MetricsEstimatePostData>
> => {
  const mutationOptions: UseMutationOptions<
    EstimateMonthlyCostApiV1MetricsEstimatePostResponse,
    AxiosError<EstimateMonthlyCostApiV1MetricsEstimatePostError>,
    Options<EstimateMonthlyCostApiV1MetricsEstimatePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await estimateMonthlyCostApiV1MetricsEstimatePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getGlobalMetricsApiV1MetricsGlobalGetQueryKey = (
  options?: Options<GetGlobalMetricsApiV1MetricsGlobalGetData>
) => createQueryKey('getGlobalMetricsApiV1MetricsGlobalGet', options);

/**
 * Get Global Metrics
 *
 * Get global metrics across all tasks and users.
 *
 * Returns aggregated metrics for the entire system (admin view).
 * Note: Currently returns user-scoped metrics for security.
 *
 * Args:
 * period: Time period (24h, 7d, 30d, or all)
 *
 * Returns:
 * PeriodMetricsResponse with global metrics
 */
export const getGlobalMetricsApiV1MetricsGlobalGetOptions = (
  options?: Options<GetGlobalMetricsApiV1MetricsGlobalGetData>
) =>
  queryOptions<
    GetGlobalMetricsApiV1MetricsGlobalGetResponse,
    AxiosError<GetGlobalMetricsApiV1MetricsGlobalGetError>,
    GetGlobalMetricsApiV1MetricsGlobalGetResponse,
    ReturnType<typeof getGlobalMetricsApiV1MetricsGlobalGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGlobalMetricsApiV1MetricsGlobalGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGlobalMetricsApiV1MetricsGlobalGetQueryKey(options),
  });

export const getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey = (
  options?: Options<GetTwoFactorStatusApiV1TwoFactorStatusGetData>
) => createQueryKey('getTwoFactorStatusApiV1TwoFactorStatusGet', options);

/**
 * Get Two Factor Status
 *
 * Get the current 2FA status for the authenticated user.
 *
 * Accepts both full and partial tokens (partial tokens during OAuth/2FA flows).
 *
 * Returns:
 * TwoFactorStatusResponse with enabled status and remaining backup codes.
 */
export const getTwoFactorStatusApiV1TwoFactorStatusGetOptions = (
  options?: Options<GetTwoFactorStatusApiV1TwoFactorStatusGetData>
) =>
  queryOptions<
    GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
    AxiosError<GetTwoFactorStatusApiV1TwoFactorStatusGetError>,
    GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
    ReturnType<typeof getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTwoFactorStatusApiV1TwoFactorStatusGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey(options),
  });

/**
 * Setup Two Factor
 *
 * Start the 2FA setup process.
 *
 * Generates a TOTP secret and QR code for the user to scan with their
 * authenticator app.
 *
 * Can be called during login (with partial token) or from settings (with full token).
 *
 * Returns:
 * TwoFactorSetupResponse with QR code and secret.
 *
 * Raises:
 * HTTPException: If 2FA is already enabled.
 */
export const setupTwoFactorApiV1TwoFactorSetupPostMutation = (
  options?: Partial<Options<SetupTwoFactorApiV1TwoFactorSetupPostData>>
): UseMutationOptions<
  SetupTwoFactorApiV1TwoFactorSetupPostResponse,
  AxiosError<SetupTwoFactorApiV1TwoFactorSetupPostError>,
  Options<SetupTwoFactorApiV1TwoFactorSetupPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SetupTwoFactorApiV1TwoFactorSetupPostResponse,
    AxiosError<SetupTwoFactorApiV1TwoFactorSetupPostError>,
    Options<SetupTwoFactorApiV1TwoFactorSetupPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await setupTwoFactorApiV1TwoFactorSetupPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enable Two Factor
 *
 * Enable 2FA after verifying the TOTP code.
 *
 * The user must first call /two-factor/setup and scan the QR code before
 * calling this endpoint with the code from their authenticator app.
 *
 * Can be called during login (with partial token) or from settings (with full token).
 *
 * Args:
 * request: Contains the 6-digit TOTP code.
 *
 * Returns:
 * TwoFactorEnableResponse with backup codes.
 *
 * Raises:
 * HTTPException: If the code is invalid or 2FA is not set up.
 */
export const enableTwoFactorApiV1TwoFactorEnablePostMutation = (
  options?: Partial<Options<EnableTwoFactorApiV1TwoFactorEnablePostData>>
): UseMutationOptions<
  EnableTwoFactorApiV1TwoFactorEnablePostResponse,
  AxiosError<EnableTwoFactorApiV1TwoFactorEnablePostError>,
  Options<EnableTwoFactorApiV1TwoFactorEnablePostData>
> => {
  const mutationOptions: UseMutationOptions<
    EnableTwoFactorApiV1TwoFactorEnablePostResponse,
    AxiosError<EnableTwoFactorApiV1TwoFactorEnablePostError>,
    Options<EnableTwoFactorApiV1TwoFactorEnablePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await enableTwoFactorApiV1TwoFactorEnablePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Disable Two Factor
 *
 * Disable 2FA for the authenticated user.
 *
 * Requires the user's password for confirmation.
 *
 * Args:
 * request: Contains the user's password.
 *
 * Returns:
 * Success message.
 *
 * Raises:
 * HTTPException: If 2FA is not enabled or password is incorrect.
 */
export const disableTwoFactorApiV1TwoFactorDisablePostMutation = (
  options?: Partial<Options<DisableTwoFactorApiV1TwoFactorDisablePostData>>
): UseMutationOptions<
  DisableTwoFactorApiV1TwoFactorDisablePostResponse,
  AxiosError<DisableTwoFactorApiV1TwoFactorDisablePostError>,
  Options<DisableTwoFactorApiV1TwoFactorDisablePostData>
> => {
  const mutationOptions: UseMutationOptions<
    DisableTwoFactorApiV1TwoFactorDisablePostResponse,
    AxiosError<DisableTwoFactorApiV1TwoFactorDisablePostError>,
    Options<DisableTwoFactorApiV1TwoFactorDisablePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await disableTwoFactorApiV1TwoFactorDisablePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Verify Two Factor
 *
 * Verify a 2FA code (TOTP or backup code).
 *
 * Accepts both full and partial tokens (partial tokens during OAuth/login flows).
 * Can be used during login or for sensitive operations after 2FA setup.
 *
 * Args:
 * request: Contains the TOTP or backup code.
 *
 * Returns:
 * TwoFactorVerifyResponse indicating if the code is valid.
 */
export const verifyTwoFactorApiV1TwoFactorVerifyPostMutation = (
  options?: Partial<Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>>
): UseMutationOptions<
  VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
  AxiosError<VerifyTwoFactorApiV1TwoFactorVerifyPostError>,
  Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
    AxiosError<VerifyTwoFactorApiV1TwoFactorVerifyPostError>,
    Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyTwoFactorApiV1TwoFactorVerifyPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Regenerate Backup Codes
 *
 * Regenerate backup codes for the authenticated user.
 *
 * This invalidates all existing backup codes and generates new ones.
 * Requires the user's password for confirmation.
 *
 * Args:
 * request: Contains the user's password.
 *
 * Returns:
 * RegenerateBackupCodesResponse with new backup codes.
 *
 * Raises:
 * HTTPException: If 2FA is not enabled or password is incorrect.
 */
export const regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostMutation = (
  options?: Partial<Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>>
): UseMutationOptions<
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
  AxiosError<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError>,
  Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
    AxiosError<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError>,
    Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listWebhooksApiV1WebhooksGetQueryKey = (
  options?: Options<ListWebhooksApiV1WebhooksGetData>
) => createQueryKey('listWebhooksApiV1WebhooksGet', options);

/**
 * List Webhooks
 *
 * List webhooks for the current user.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number
 * page_size: Items per page
 * status: Optional status filter
 *
 * Returns:
 * Paginated list of webhooks
 */
export const listWebhooksApiV1WebhooksGetOptions = (
  options?: Options<ListWebhooksApiV1WebhooksGetData>
) =>
  queryOptions<
    ListWebhooksApiV1WebhooksGetResponse,
    AxiosError<ListWebhooksApiV1WebhooksGetError>,
    ListWebhooksApiV1WebhooksGetResponse,
    ReturnType<typeof listWebhooksApiV1WebhooksGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listWebhooksApiV1WebhooksGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listWebhooksApiV1WebhooksGetQueryKey(options),
  });

export const listWebhooksApiV1WebhooksGetInfiniteQueryKey = (
  options?: Options<ListWebhooksApiV1WebhooksGetData>
): QueryKey<Options<ListWebhooksApiV1WebhooksGetData>> =>
  createQueryKey('listWebhooksApiV1WebhooksGet', options, true);

/**
 * List Webhooks
 *
 * List webhooks for the current user.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number
 * page_size: Items per page
 * status: Optional status filter
 *
 * Returns:
 * Paginated list of webhooks
 */
export const listWebhooksApiV1WebhooksGetInfiniteOptions = (
  options?: Options<ListWebhooksApiV1WebhooksGetData>
) =>
  infiniteQueryOptions<
    ListWebhooksApiV1WebhooksGetResponse,
    AxiosError<ListWebhooksApiV1WebhooksGetError>,
    InfiniteData<ListWebhooksApiV1WebhooksGetResponse>,
    QueryKey<Options<ListWebhooksApiV1WebhooksGetData>>,
    | number
    | Pick<
        QueryKey<Options<ListWebhooksApiV1WebhooksGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListWebhooksApiV1WebhooksGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWebhooksApiV1WebhooksGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listWebhooksApiV1WebhooksGetInfiniteQueryKey(options),
    }
  );

/**
 * Create Webhook
 *
 * Create a new webhook.
 *
 * The response includes the generated secret which should be stored securely.
 * The secret is only shown once on creation and cannot be retrieved later.
 *
 * Args:
 * webhook_data: Webhook creation data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Created webhook with secret
 */
export const createWebhookApiV1WebhooksPostMutation = (
  options?: Partial<Options<CreateWebhookApiV1WebhooksPostData>>
): UseMutationOptions<
  CreateWebhookApiV1WebhooksPostResponse,
  AxiosError<CreateWebhookApiV1WebhooksPostError>,
  Options<CreateWebhookApiV1WebhooksPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateWebhookApiV1WebhooksPostResponse,
    AxiosError<CreateWebhookApiV1WebhooksPostError>,
    Options<CreateWebhookApiV1WebhooksPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createWebhookApiV1WebhooksPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Webhook
 *
 * Delete a webhook.
 *
 * Args:
 * webhook_id: Webhook ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const deleteWebhookApiV1WebhooksWebhookIdDeleteMutation = (
  options?: Partial<Options<DeleteWebhookApiV1WebhooksWebhookIdDeleteData>>
): UseMutationOptions<
  DeleteWebhookApiV1WebhooksWebhookIdDeleteResponse,
  AxiosError<DeleteWebhookApiV1WebhooksWebhookIdDeleteError>,
  Options<DeleteWebhookApiV1WebhooksWebhookIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteWebhookApiV1WebhooksWebhookIdDeleteResponse,
    AxiosError<DeleteWebhookApiV1WebhooksWebhookIdDeleteError>,
    Options<DeleteWebhookApiV1WebhooksWebhookIdDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteWebhookApiV1WebhooksWebhookIdDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getWebhookApiV1WebhooksWebhookIdGetQueryKey = (
  options: Options<GetWebhookApiV1WebhooksWebhookIdGetData>
) => createQueryKey('getWebhookApiV1WebhooksWebhookIdGet', options);

/**
 * Get Webhook
 *
 * Get a specific webhook by ID.
 *
 * Args:
 * webhook_id: Webhook ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Webhook details
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const getWebhookApiV1WebhooksWebhookIdGetOptions = (
  options: Options<GetWebhookApiV1WebhooksWebhookIdGetData>
) =>
  queryOptions<
    GetWebhookApiV1WebhooksWebhookIdGetResponse,
    AxiosError<GetWebhookApiV1WebhooksWebhookIdGetError>,
    GetWebhookApiV1WebhooksWebhookIdGetResponse,
    ReturnType<typeof getWebhookApiV1WebhooksWebhookIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getWebhookApiV1WebhooksWebhookIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getWebhookApiV1WebhooksWebhookIdGetQueryKey(options),
  });

/**
 * Update Webhook
 *
 * Update a webhook.
 *
 * Args:
 * webhook_id: Webhook ID
 * webhook_data: Update data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Updated webhook
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const updateWebhookApiV1WebhooksWebhookIdPatchMutation = (
  options?: Partial<Options<UpdateWebhookApiV1WebhooksWebhookIdPatchData>>
): UseMutationOptions<
  UpdateWebhookApiV1WebhooksWebhookIdPatchResponse,
  AxiosError<UpdateWebhookApiV1WebhooksWebhookIdPatchError>,
  Options<UpdateWebhookApiV1WebhooksWebhookIdPatchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateWebhookApiV1WebhooksWebhookIdPatchResponse,
    AxiosError<UpdateWebhookApiV1WebhooksWebhookIdPatchError>,
    Options<UpdateWebhookApiV1WebhooksWebhookIdPatchData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateWebhookApiV1WebhooksWebhookIdPatch({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Regenerate Webhook Secret
 *
 * Regenerate the secret for a webhook.
 *
 * The old secret will be invalidated immediately.
 *
 * Args:
 * webhook_id: Webhook ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Webhook with new secret
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const regenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostMutation = (
  options?: Partial<Options<RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostData>>
): UseMutationOptions<
  RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostResponse,
  AxiosError<RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostError>,
  Options<RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostResponse,
    AxiosError<RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostError>,
    Options<RegenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await regenerateWebhookSecretApiV1WebhooksWebhookIdRegenerateSecretPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Test Webhook
 *
 * Send a test event to a webhook.
 *
 * This sends a test payload to verify the webhook endpoint is working.
 *
 * Args:
 * webhook_id: Webhook ID
 * test_data: Test configuration
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Test result with response details
 */
export const testWebhookApiV1WebhooksWebhookIdTestPostMutation = (
  options?: Partial<Options<TestWebhookApiV1WebhooksWebhookIdTestPostData>>
): UseMutationOptions<
  TestWebhookApiV1WebhooksWebhookIdTestPostResponse,
  AxiosError<TestWebhookApiV1WebhooksWebhookIdTestPostError>,
  Options<TestWebhookApiV1WebhooksWebhookIdTestPostData>
> => {
  const mutationOptions: UseMutationOptions<
    TestWebhookApiV1WebhooksWebhookIdTestPostResponse,
    AxiosError<TestWebhookApiV1WebhooksWebhookIdTestPostError>,
    Options<TestWebhookApiV1WebhooksWebhookIdTestPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await testWebhookApiV1WebhooksWebhookIdTestPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetQueryKey = (
  options: Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>
) => createQueryKey('listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGet', options);

/**
 * List Webhook Deliveries
 *
 * List delivery history for a webhook.
 *
 * Args:
 * webhook_id: Webhook ID
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number
 * page_size: Items per page
 * delivery_status: Optional status filter
 *
 * Returns:
 * Paginated list of deliveries
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetOptions = (
  options: Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>
) =>
  queryOptions<
    ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetResponse,
    AxiosError<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetError>,
    ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetResponse,
    ReturnType<typeof listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetQueryKey(options),
  });

export const listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetInfiniteQueryKey = (
  options: Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>
): QueryKey<Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>> =>
  createQueryKey('listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGet', options, true);

/**
 * List Webhook Deliveries
 *
 * List delivery history for a webhook.
 *
 * Args:
 * webhook_id: Webhook ID
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number
 * page_size: Items per page
 * delivery_status: Optional status filter
 *
 * Returns:
 * Paginated list of deliveries
 *
 * Raises:
 * HTTPException: If webhook not found
 */
export const listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetInfiniteOptions = (
  options: Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>
) =>
  infiniteQueryOptions<
    ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetResponse,
    AxiosError<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetError>,
    InfiniteData<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetResponse>,
    QueryKey<Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>>,
    | number
    | Pick<
        QueryKey<Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listWebhookDeliveriesApiV1WebhooksWebhookIdDeliveriesGetInfiniteQueryKey(options),
    }
  );

export const getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetQueryKey = (
  options: Options<GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetData>
) => createQueryKey('getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGet', options);

/**
 * Get Webhook Delivery
 *
 * Get a specific delivery by ID.
 *
 * Args:
 * webhook_id: Webhook ID
 * delivery_id: Delivery ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Delivery details
 *
 * Raises:
 * HTTPException: If webhook or delivery not found
 */
export const getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetOptions = (
  options: Options<GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetData>
) =>
  queryOptions<
    GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetResponse,
    AxiosError<GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetError>,
    GetWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetResponse,
    ReturnType<typeof getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getWebhookDeliveryApiV1WebhooksWebhookIdDeliveriesDeliveryIdGetQueryKey(options),
  });

export const getOauthProvidersOauthProvidersGetQueryKey = (
  options?: Options<GetOauthProvidersOauthProvidersGetData>
) => createQueryKey('getOauthProvidersOauthProvidersGet', options);

/**
 * Get Oauth Providers
 *
 * Get available OAuth providers and their configuration status.
 *
 * Returns:
 * Dictionary of provider names and whether they are configured.
 */
export const getOauthProvidersOauthProvidersGetOptions = (
  options?: Options<GetOauthProvidersOauthProvidersGetData>
) =>
  queryOptions<
    GetOauthProvidersOauthProvidersGetResponse,
    AxiosError<DefaultError>,
    GetOauthProvidersOauthProvidersGetResponse,
    ReturnType<typeof getOauthProvidersOauthProvidersGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOauthProvidersOauthProvidersGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOauthProvidersOauthProvidersGetQueryKey(options),
  });

export const oauthAuthorizeOauthProviderAuthorizeGetQueryKey = (
  options: Options<OauthAuthorizeOauthProviderAuthorizeGetData>
) => createQueryKey('oauthAuthorizeOauthProviderAuthorizeGet', options);

/**
 * Oauth Authorize
 *
 * Start OAuth authorization flow.
 *
 * Redirects the user to the OAuth provider's authorization page.
 *
 * Args:
 * provider: OAuth provider name (github, google, microsoft).
 * redirect_url: Optional URL to redirect to after successful auth.
 *
 * Returns:
 * Redirect to the OAuth provider.
 *
 * Raises:
 * HTTPException: If provider is not supported or not configured.
 */
export const oauthAuthorizeOauthProviderAuthorizeGetOptions = (
  options: Options<OauthAuthorizeOauthProviderAuthorizeGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthAuthorizeOauthProviderAuthorizeGetError>,
    unknown,
    ReturnType<typeof oauthAuthorizeOauthProviderAuthorizeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthAuthorizeOauthProviderAuthorizeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthAuthorizeOauthProviderAuthorizeGetQueryKey(options),
  });

export const oauthAuthorizeLinkOauthProviderAuthorizeLinkGetQueryKey = (
  options: Options<OauthAuthorizeLinkOauthProviderAuthorizeLinkGetData>
) => createQueryKey('oauthAuthorizeLinkOauthProviderAuthorizeLinkGet', options);

/**
 * Oauth Authorize Link
 *
 * Start OAuth authorization flow for linking to existing account.
 *
 * Requires authentication. Links the OAuth account to the current user.
 *
 * Args:
 * provider: OAuth provider name.
 * redirect_url: Optional URL to redirect to after linking.
 *
 * Returns:
 * Redirect to the OAuth provider.
 */
export const oauthAuthorizeLinkOauthProviderAuthorizeLinkGetOptions = (
  options: Options<OauthAuthorizeLinkOauthProviderAuthorizeLinkGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthAuthorizeLinkOauthProviderAuthorizeLinkGetError>,
    unknown,
    ReturnType<typeof oauthAuthorizeLinkOauthProviderAuthorizeLinkGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthAuthorizeLinkOauthProviderAuthorizeLinkGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthAuthorizeLinkOauthProviderAuthorizeLinkGetQueryKey(options),
  });

export const oauthCallbackOauthProviderCallbackGetQueryKey = (
  options: Options<OauthCallbackOauthProviderCallbackGetData>
) => createQueryKey('oauthCallbackOauthProviderCallbackGet', options);

/**
 * Oauth Callback
 *
 * Handle OAuth callback.
 *
 * Exchanges the authorization code for tokens and creates/links user account.
 * Then redirects to frontend with success/error status.
 *
 * Args:
 * provider: OAuth provider name.
 * code: Authorization code from OAuth provider.
 * state: CSRF protection state.
 *
 * Returns:
 * Redirect to frontend.
 *
 * Raises:
 * HTTPException: If callback fails.
 */
export const oauthCallbackOauthProviderCallbackGetOptions = (
  options: Options<OauthCallbackOauthProviderCallbackGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthCallbackOauthProviderCallbackGetError>,
    unknown,
    ReturnType<typeof oauthCallbackOauthProviderCallbackGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthCallbackOauthProviderCallbackGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthCallbackOauthProviderCallbackGetQueryKey(options),
  });

export const getConnectedAccountsOauthAccountsGetQueryKey = (
  options?: Options<GetConnectedAccountsOauthAccountsGetData>
) => createQueryKey('getConnectedAccountsOauthAccountsGet', options);

/**
 * Get Connected Accounts
 *
 * Get all OAuth accounts linked to the current user.
 *
 * Returns:
 * List of connected OAuth accounts.
 */
export const getConnectedAccountsOauthAccountsGetOptions = (
  options?: Options<GetConnectedAccountsOauthAccountsGetData>
) =>
  queryOptions<
    GetConnectedAccountsOauthAccountsGetResponse,
    AxiosError<GetConnectedAccountsOauthAccountsGetError>,
    GetConnectedAccountsOauthAccountsGetResponse,
    ReturnType<typeof getConnectedAccountsOauthAccountsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getConnectedAccountsOauthAccountsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getConnectedAccountsOauthAccountsGetQueryKey(options),
  });

/**
 * Unlink Oauth Account
 *
 * Unlink an OAuth account from the current user.
 *
 * Args:
 * provider: OAuth provider to unlink.
 *
 * Returns:
 * Success message.
 *
 * Raises:
 * HTTPException: If unlinking fails.
 */
export const unlinkOauthAccountOauthProviderUnlinkDeleteMutation = (
  options?: Partial<Options<UnlinkOauthAccountOauthProviderUnlinkDeleteData>>
): UseMutationOptions<
  UnlinkOauthAccountOauthProviderUnlinkDeleteResponse,
  AxiosError<UnlinkOauthAccountOauthProviderUnlinkDeleteError>,
  Options<UnlinkOauthAccountOauthProviderUnlinkDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    UnlinkOauthAccountOauthProviderUnlinkDeleteResponse,
    AxiosError<UnlinkOauthAccountOauthProviderUnlinkDeleteError>,
    Options<UnlinkOauthAccountOauthProviderUnlinkDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await unlinkOauthAccountOauthProviderUnlinkDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Send Test Email
 *
 * Send a test email to verify SMTP configuration.
 *
 * **Development Only** - Remove this endpoint in production.
 *
 * Args:
 * recipient_email: Email address to send test email to
 * db: Database session
 *
 * Returns:
 * dict: Success message with details
 *
 * Raises:
 * HTTPException: If email sending fails
 */
export const sendTestEmailApiV1TestSendTestEmailPostMutation = (
  options?: Partial<Options<SendTestEmailApiV1TestSendTestEmailPostData>>
): UseMutationOptions<
  SendTestEmailApiV1TestSendTestEmailPostResponse,
  AxiosError<SendTestEmailApiV1TestSendTestEmailPostError>,
  Options<SendTestEmailApiV1TestSendTestEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SendTestEmailApiV1TestSendTestEmailPostResponse,
    AxiosError<SendTestEmailApiV1TestSendTestEmailPostError>,
    Options<SendTestEmailApiV1TestSendTestEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await sendTestEmailApiV1TestSendTestEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listRolesApiV1AdminRolesGetQueryKey = (
  options?: Options<ListRolesApiV1AdminRolesGetData>
) => createQueryKey('listRolesApiV1AdminRolesGet', options);

/**
 * List Roles
 *
 * List all roles with their permissions.
 *
 * Requires: Admin role or superuser access
 *
 * Returns:
 * List of all roles with permissions
 */
export const listRolesApiV1AdminRolesGetOptions = (
  options?: Options<ListRolesApiV1AdminRolesGetData>
) =>
  queryOptions<
    ListRolesApiV1AdminRolesGetResponse,
    AxiosError<ListRolesApiV1AdminRolesGetError>,
    ListRolesApiV1AdminRolesGetResponse,
    ReturnType<typeof listRolesApiV1AdminRolesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listRolesApiV1AdminRolesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listRolesApiV1AdminRolesGetQueryKey(options),
  });

export const getRoleApiV1AdminRolesRoleIdGetQueryKey = (
  options: Options<GetRoleApiV1AdminRolesRoleIdGetData>
) => createQueryKey('getRoleApiV1AdminRolesRoleIdGet', options);

/**
 * Get Role
 *
 * Get a specific role with its permissions.
 *
 * Requires: Admin role or superuser access
 *
 * Args:
 * role_id: Role ID
 *
 * Returns:
 * Role with permissions
 *
 * Raises:
 * HTTPException: If role not found
 */
export const getRoleApiV1AdminRolesRoleIdGetOptions = (
  options: Options<GetRoleApiV1AdminRolesRoleIdGetData>
) =>
  queryOptions<
    GetRoleApiV1AdminRolesRoleIdGetResponse,
    AxiosError<GetRoleApiV1AdminRolesRoleIdGetError>,
    GetRoleApiV1AdminRolesRoleIdGetResponse,
    ReturnType<typeof getRoleApiV1AdminRolesRoleIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRoleApiV1AdminRolesRoleIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRoleApiV1AdminRolesRoleIdGetQueryKey(options),
  });

export const listPermissionsApiV1AdminPermissionsGetQueryKey = (
  options?: Options<ListPermissionsApiV1AdminPermissionsGetData>
) => createQueryKey('listPermissionsApiV1AdminPermissionsGet', options);

/**
 * List Permissions
 *
 * List all available permissions.
 *
 * Requires: Admin role or superuser access
 *
 * Returns:
 * List of all permissions
 */
export const listPermissionsApiV1AdminPermissionsGetOptions = (
  options?: Options<ListPermissionsApiV1AdminPermissionsGetData>
) =>
  queryOptions<
    ListPermissionsApiV1AdminPermissionsGetResponse,
    AxiosError<ListPermissionsApiV1AdminPermissionsGetError>,
    ListPermissionsApiV1AdminPermissionsGetResponse,
    ReturnType<typeof listPermissionsApiV1AdminPermissionsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listPermissionsApiV1AdminPermissionsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listPermissionsApiV1AdminPermissionsGetQueryKey(options),
  });

/**
 * Remove User Role
 *
 * Remove a role from a user.
 *
 * Requires: Admin role or superuser access
 *
 * Args:
 * user_id: User ID to remove role from
 *
 * Raises:
 * HTTPException: If user not found
 */
export const removeUserRoleApiV1AdminUsersUserIdRoleDeleteMutation = (
  options?: Partial<Options<RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteData>>
): UseMutationOptions<
  RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteResponse,
  AxiosError<RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteError>,
  Options<RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteResponse,
    AxiosError<RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteError>,
    Options<RemoveUserRoleApiV1AdminUsersUserIdRoleDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await removeUserRoleApiV1AdminUsersUserIdRoleDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Assign User Role
 *
 * Assign a role to a user.
 *
 * Requires: Admin role or superuser access
 *
 * Args:
 * user_id: User ID to assign role to
 * assignment: Role assignment data containing role_id
 *
 * Returns:
 * Updated user permissions
 *
 * Raises:
 * HTTPException: If user or role not found
 */
export const assignUserRoleApiV1AdminUsersUserIdRolePostMutation = (
  options?: Partial<Options<AssignUserRoleApiV1AdminUsersUserIdRolePostData>>
): UseMutationOptions<
  AssignUserRoleApiV1AdminUsersUserIdRolePostResponse,
  AxiosError<AssignUserRoleApiV1AdminUsersUserIdRolePostError>,
  Options<AssignUserRoleApiV1AdminUsersUserIdRolePostData>
> => {
  const mutationOptions: UseMutationOptions<
    AssignUserRoleApiV1AdminUsersUserIdRolePostResponse,
    AxiosError<AssignUserRoleApiV1AdminUsersUserIdRolePostError>,
    Options<AssignUserRoleApiV1AdminUsersUserIdRolePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await assignUserRoleApiV1AdminUsersUserIdRolePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserPermissionsApiV1AdminUsersUserIdPermissionsGetQueryKey = (
  options: Options<GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetData>
) => createQueryKey('getUserPermissionsApiV1AdminUsersUserIdPermissionsGet', options);

/**
 * Get User Permissions
 *
 * Get all permissions for a specific user.
 *
 * Requires: Admin role or superuser access
 *
 * Args:
 * user_id: User ID
 *
 * Returns:
 * User permissions including role and superuser status
 *
 * Raises:
 * HTTPException: If user not found
 */
export const getUserPermissionsApiV1AdminUsersUserIdPermissionsGetOptions = (
  options: Options<GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetData>
) =>
  queryOptions<
    GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetResponse,
    AxiosError<GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetError>,
    GetUserPermissionsApiV1AdminUsersUserIdPermissionsGetResponse,
    ReturnType<typeof getUserPermissionsApiV1AdminUsersUserIdPermissionsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserPermissionsApiV1AdminUsersUserIdPermissionsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserPermissionsApiV1AdminUsersUserIdPermissionsGetQueryKey(options),
  });

export const listUsersWithRolesApiV1AdminUsersGetQueryKey = (
  options?: Options<ListUsersWithRolesApiV1AdminUsersGetData>
) => createQueryKey('listUsersWithRolesApiV1AdminUsersGet', options);

/**
 * List Users With Roles
 *
 * List all users with their roles and permissions.
 *
 * Requires: Admin role or superuser access
 *
 * Returns:
 * List of users with their permissions
 */
export const listUsersWithRolesApiV1AdminUsersGetOptions = (
  options?: Options<ListUsersWithRolesApiV1AdminUsersGetData>
) =>
  queryOptions<
    ListUsersWithRolesApiV1AdminUsersGetResponse,
    AxiosError<ListUsersWithRolesApiV1AdminUsersGetError>,
    ListUsersWithRolesApiV1AdminUsersGetResponse,
    ReturnType<typeof listUsersWithRolesApiV1AdminUsersGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUsersWithRolesApiV1AdminUsersGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUsersWithRolesApiV1AdminUsersGetQueryKey(options),
  });
