// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import {
  changeEmailApiV1AuthChangeEmailPost,
  changePasswordApiV1AuthChangePasswordPost,
  createTaskApiV1TasksPost,
  deleteTaskApiV1TasksTaskIdDelete,
  disableTwoFactorApiV1TwoFactorDisablePost,
  enableTwoFactorApiV1TwoFactorEnablePost,
  forgotPasswordApiV1AuthForgotPasswordPost,
  getConnectedAccountsApiV1OauthAccountsGet,
  getCurrentUserInfoApiV1AuthMeGet,
  getCurrentUserInfoApiV1UsersMeGet,
  getOauthProvidersApiV1OauthProvidersGet,
  getTaskApiV1TasksTaskIdGet,
  getTwoFactorStatusApiV1TwoFactorStatusGet,
  healthCheckHealthGet,
  listTasksApiV1TasksGet,
  loginUserApiV1AuthLoginPost,
  logoutApiV1AuthLogoutPost,
  oauthAuthorizeApiV1OauthProviderAuthorizeGet,
  oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGet,
  oauthCallbackApiV1OauthProviderCallbackGet,
  type Options,
  refreshApiV1AuthRefreshPost,
  regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPost,
  registerUserApiV1AuthRegisterPost,
  resendVerificationApiV1AuthResendVerificationPost,
  resetPasswordApiV1AuthResetPasswordPost,
  sendTestEmailApiV1TestSendTestEmailPost,
  setupTwoFactorApiV1TwoFactorSetupPost,
  unlinkOauthAccountApiV1OauthProviderUnlinkDelete,
  updateTaskApiV1TasksTaskIdPatch,
  verifyEmailApiV1AuthVerifyEmailPost,
  verifyTwoFactorApiV1TwoFactorVerifyPost,
} from '../sdk.gen';
import type {
  ChangeEmailApiV1AuthChangeEmailPostData,
  ChangeEmailApiV1AuthChangeEmailPostError,
  ChangeEmailApiV1AuthChangeEmailPostResponse,
  ChangePasswordApiV1AuthChangePasswordPostData,
  ChangePasswordApiV1AuthChangePasswordPostError,
  ChangePasswordApiV1AuthChangePasswordPostResponse,
  CreateTaskApiV1TasksPostData,
  CreateTaskApiV1TasksPostError,
  CreateTaskApiV1TasksPostResponse,
  DeleteTaskApiV1TasksTaskIdDeleteData,
  DeleteTaskApiV1TasksTaskIdDeleteError,
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  DisableTwoFactorApiV1TwoFactorDisablePostData,
  DisableTwoFactorApiV1TwoFactorDisablePostError,
  DisableTwoFactorApiV1TwoFactorDisablePostResponse,
  EnableTwoFactorApiV1TwoFactorEnablePostData,
  EnableTwoFactorApiV1TwoFactorEnablePostError,
  EnableTwoFactorApiV1TwoFactorEnablePostResponse,
  ForgotPasswordApiV1AuthForgotPasswordPostData,
  ForgotPasswordApiV1AuthForgotPasswordPostError,
  ForgotPasswordApiV1AuthForgotPasswordPostResponse,
  GetConnectedAccountsApiV1OauthAccountsGetData,
  GetConnectedAccountsApiV1OauthAccountsGetError,
  GetConnectedAccountsApiV1OauthAccountsGetResponse,
  GetCurrentUserInfoApiV1AuthMeGetData,
  GetCurrentUserInfoApiV1AuthMeGetError,
  GetCurrentUserInfoApiV1AuthMeGetResponse,
  GetCurrentUserInfoApiV1UsersMeGetData,
  GetCurrentUserInfoApiV1UsersMeGetError,
  GetCurrentUserInfoApiV1UsersMeGetResponse,
  GetOauthProvidersApiV1OauthProvidersGetData,
  GetOauthProvidersApiV1OauthProvidersGetResponse,
  GetTaskApiV1TasksTaskIdGetData,
  GetTaskApiV1TasksTaskIdGetError,
  GetTaskApiV1TasksTaskIdGetResponse,
  GetTwoFactorStatusApiV1TwoFactorStatusGetData,
  GetTwoFactorStatusApiV1TwoFactorStatusGetError,
  GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
  HealthCheckHealthGetData,
  HealthCheckHealthGetResponse,
  ListTasksApiV1TasksGetData,
  ListTasksApiV1TasksGetError,
  ListTasksApiV1TasksGetResponse,
  LoginUserApiV1AuthLoginPostData,
  LoginUserApiV1AuthLoginPostError,
  LoginUserApiV1AuthLoginPostResponse,
  LogoutApiV1AuthLogoutPostData,
  LogoutApiV1AuthLogoutPostError,
  LogoutApiV1AuthLogoutPostResponse,
  OauthAuthorizeApiV1OauthProviderAuthorizeGetData,
  OauthAuthorizeApiV1OauthProviderAuthorizeGetError,
  OauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetData,
  OauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetError,
  OauthCallbackApiV1OauthProviderCallbackGetData,
  OauthCallbackApiV1OauthProviderCallbackGetError,
  RefreshApiV1AuthRefreshPostData,
  RefreshApiV1AuthRefreshPostError,
  RefreshApiV1AuthRefreshPostResponse,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError,
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
  RegisterUserApiV1AuthRegisterPostData,
  RegisterUserApiV1AuthRegisterPostError,
  RegisterUserApiV1AuthRegisterPostResponse,
  ResendVerificationApiV1AuthResendVerificationPostData,
  ResendVerificationApiV1AuthResendVerificationPostError,
  ResendVerificationApiV1AuthResendVerificationPostResponse,
  ResetPasswordApiV1AuthResetPasswordPostData,
  ResetPasswordApiV1AuthResetPasswordPostError,
  ResetPasswordApiV1AuthResetPasswordPostResponse,
  SendTestEmailApiV1TestSendTestEmailPostData,
  SendTestEmailApiV1TestSendTestEmailPostError,
  SendTestEmailApiV1TestSendTestEmailPostResponse,
  SetupTwoFactorApiV1TwoFactorSetupPostData,
  SetupTwoFactorApiV1TwoFactorSetupPostError,
  SetupTwoFactorApiV1TwoFactorSetupPostResponse,
  UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteData,
  UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteError,
  UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteResponse,
  UpdateTaskApiV1TasksTaskIdPatchData,
  UpdateTaskApiV1TasksTaskIdPatchError,
  UpdateTaskApiV1TasksTaskIdPatchResponse,
  VerifyEmailApiV1AuthVerifyEmailPostData,
  VerifyEmailApiV1AuthVerifyEmailPostError,
  VerifyEmailApiV1AuthVerifyEmailPostResponse,
  VerifyTwoFactorApiV1TwoFactorVerifyPostData,
  VerifyTwoFactorApiV1TwoFactorVerifyPostError,
  VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckHealthGetQueryKey = (options?: Options<HealthCheckHealthGetData>) =>
  createQueryKey('healthCheckHealthGet', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns:
 * Dictionary with status message
 */
export const healthCheckHealthGetOptions = (options?: Options<HealthCheckHealthGetData>) =>
  queryOptions<
    HealthCheckHealthGetResponse,
    AxiosError<DefaultError>,
    HealthCheckHealthGetResponse,
    ReturnType<typeof healthCheckHealthGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options),
  });

/**
 * Register User
 *
 * Register a new user.
 *
 * Args:
 * user_data: User registration data
 * db: Database session
 *
 * Returns:
 * Created user instance
 *
 * Raises:
 * HTTPException: If email already exists
 */
export const registerUserApiV1AuthRegisterPostMutation = (
  options?: Partial<Options<RegisterUserApiV1AuthRegisterPostData>>
): UseMutationOptions<
  RegisterUserApiV1AuthRegisterPostResponse,
  AxiosError<RegisterUserApiV1AuthRegisterPostError>,
  Options<RegisterUserApiV1AuthRegisterPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegisterUserApiV1AuthRegisterPostResponse,
    AxiosError<RegisterUserApiV1AuthRegisterPostError>,
    Options<RegisterUserApiV1AuthRegisterPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await registerUserApiV1AuthRegisterPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login User
 *
 * Authenticate user and return JWT tokens.
 *
 * Args:
 * user_data: User login credentials
 * db: Database session
 *
 * Returns:
 * JWT access and refresh tokens
 *
 * Raises:
 * HTTPException: If credentials are invalid
 */
export const loginUserApiV1AuthLoginPostMutation = (
  options?: Partial<Options<LoginUserApiV1AuthLoginPostData>>
): UseMutationOptions<
  LoginUserApiV1AuthLoginPostResponse,
  AxiosError<LoginUserApiV1AuthLoginPostError>,
  Options<LoginUserApiV1AuthLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LoginUserApiV1AuthLoginPostResponse,
    AxiosError<LoginUserApiV1AuthLoginPostError>,
    Options<LoginUserApiV1AuthLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loginUserApiV1AuthLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout
 *
 * Logout user, clears cookies and revokes refresh token.
 *
 * Args:
 * response: FastAPI response object (to clear cookies)
 * refresh_token: Refresh token from cookie
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 */
export const logoutApiV1AuthLogoutPostMutation = (
  options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>
): UseMutationOptions<
  LogoutApiV1AuthLogoutPostResponse,
  AxiosError<LogoutApiV1AuthLogoutPostError>,
  Options<LogoutApiV1AuthLogoutPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LogoutApiV1AuthLogoutPostResponse,
    AxiosError<LogoutApiV1AuthLogoutPostError>,
    Options<LogoutApiV1AuthLogoutPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await logoutApiV1AuthLogoutPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Refresh
 *
 * Refresh access token using refresh token from cookie.
 *
 * Implements token rotation: issues new refresh token and revokes old one.
 *
 * Args:
 * response: FastAPI response object (to set new cookies)
 * request: FastAPI request object (for IP address)
 * refresh_token: Refresh token from cookie
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If refresh token is invalid, expired, or revoked
 */
export const refreshApiV1AuthRefreshPostMutation = (
  options?: Partial<Options<RefreshApiV1AuthRefreshPostData>>
): UseMutationOptions<
  RefreshApiV1AuthRefreshPostResponse,
  AxiosError<RefreshApiV1AuthRefreshPostError>,
  Options<RefreshApiV1AuthRefreshPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RefreshApiV1AuthRefreshPostResponse,
    AxiosError<RefreshApiV1AuthRefreshPostError>,
    Options<RefreshApiV1AuthRefreshPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await refreshApiV1AuthRefreshPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1AuthMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1AuthMeGet', options);

/**
 * Get Current User Info
 *
 * Get current authenticated user information.
 *
 * Args:
 * current_user: Current authenticated user
 *
 * Returns:
 * UserResponse: Current user data
 */
export const getCurrentUserInfoApiV1AuthMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    AxiosError<GetCurrentUserInfoApiV1AuthMeGetError>,
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1AuthMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1AuthMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1AuthMeGetQueryKey(options),
  });

/**
 * Verify Email
 *
 * Verify user email with verification token.
 *
 * Args:
 * request_data: Email verification token
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If token is invalid or expired
 */
export const verifyEmailApiV1AuthVerifyEmailPostMutation = (
  options?: Partial<Options<VerifyEmailApiV1AuthVerifyEmailPostData>>
): UseMutationOptions<
  VerifyEmailApiV1AuthVerifyEmailPostResponse,
  AxiosError<VerifyEmailApiV1AuthVerifyEmailPostError>,
  Options<VerifyEmailApiV1AuthVerifyEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyEmailApiV1AuthVerifyEmailPostResponse,
    AxiosError<VerifyEmailApiV1AuthVerifyEmailPostError>,
    Options<VerifyEmailApiV1AuthVerifyEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyEmailApiV1AuthVerifyEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Resend Verification
 *
 * Resend verification email to user.
 *
 * Args:
 * request_data: User email address
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If email not found
 */
export const resendVerificationApiV1AuthResendVerificationPostMutation = (
  options?: Partial<Options<ResendVerificationApiV1AuthResendVerificationPostData>>
): UseMutationOptions<
  ResendVerificationApiV1AuthResendVerificationPostResponse,
  AxiosError<ResendVerificationApiV1AuthResendVerificationPostError>,
  Options<ResendVerificationApiV1AuthResendVerificationPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ResendVerificationApiV1AuthResendVerificationPostResponse,
    AxiosError<ResendVerificationApiV1AuthResendVerificationPostError>,
    Options<ResendVerificationApiV1AuthResendVerificationPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await resendVerificationApiV1AuthResendVerificationPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Forgot Password
 *
 * Request password reset for user account.
 *
 * Args:
 * request_data: User email address
 * db: Database session
 *
 * Returns:
 * dict: Success message (always returns success for security)
 */
export const forgotPasswordApiV1AuthForgotPasswordPostMutation = (
  options?: Partial<Options<ForgotPasswordApiV1AuthForgotPasswordPostData>>
): UseMutationOptions<
  ForgotPasswordApiV1AuthForgotPasswordPostResponse,
  AxiosError<ForgotPasswordApiV1AuthForgotPasswordPostError>,
  Options<ForgotPasswordApiV1AuthForgotPasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ForgotPasswordApiV1AuthForgotPasswordPostResponse,
    AxiosError<ForgotPasswordApiV1AuthForgotPasswordPostError>,
    Options<ForgotPasswordApiV1AuthForgotPasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await forgotPasswordApiV1AuthForgotPasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reset Password
 *
 * Reset user password with reset token.
 *
 * Args:
 * request_data: Reset token and new password
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If token is invalid or expired
 */
export const resetPasswordApiV1AuthResetPasswordPostMutation = (
  options?: Partial<Options<ResetPasswordApiV1AuthResetPasswordPostData>>
): UseMutationOptions<
  ResetPasswordApiV1AuthResetPasswordPostResponse,
  AxiosError<ResetPasswordApiV1AuthResetPasswordPostError>,
  Options<ResetPasswordApiV1AuthResetPasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ResetPasswordApiV1AuthResetPasswordPostResponse,
    AxiosError<ResetPasswordApiV1AuthResetPasswordPostError>,
    Options<ResetPasswordApiV1AuthResetPasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await resetPasswordApiV1AuthResetPasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Change Password
 *
 * Change password for authenticated user.
 *
 * Args:
 * request_data: Current password and new password
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If current password is incorrect
 */
export const changePasswordApiV1AuthChangePasswordPostMutation = (
  options?: Partial<Options<ChangePasswordApiV1AuthChangePasswordPostData>>
): UseMutationOptions<
  ChangePasswordApiV1AuthChangePasswordPostResponse,
  AxiosError<ChangePasswordApiV1AuthChangePasswordPostError>,
  Options<ChangePasswordApiV1AuthChangePasswordPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangePasswordApiV1AuthChangePasswordPostResponse,
    AxiosError<ChangePasswordApiV1AuthChangePasswordPostError>,
    Options<ChangePasswordApiV1AuthChangePasswordPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await changePasswordApiV1AuthChangePasswordPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Change Email
 *
 * Request email change for authenticated user.
 *
 * Sends verification email to new address.
 *
 * Args:
 * request_data: New email address and password
 * current_user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If password is incorrect or new email already registered
 */
export const changeEmailApiV1AuthChangeEmailPostMutation = (
  options?: Partial<Options<ChangeEmailApiV1AuthChangeEmailPostData>>
): UseMutationOptions<
  ChangeEmailApiV1AuthChangeEmailPostResponse,
  AxiosError<ChangeEmailApiV1AuthChangeEmailPostError>,
  Options<ChangeEmailApiV1AuthChangeEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangeEmailApiV1AuthChangeEmailPostResponse,
    AxiosError<ChangeEmailApiV1AuthChangeEmailPostError>,
    Options<ChangeEmailApiV1AuthChangeEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await changeEmailApiV1AuthChangeEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1UsersMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1UsersMeGet', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Args:
 * current_user: Current authenticated user
 *
 * Returns:
 * Current user data
 */
export const getCurrentUserInfoApiV1UsersMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    AxiosError<GetCurrentUserInfoApiV1UsersMeGetError>,
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1UsersMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1UsersMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1UsersMeGetQueryKey(options),
  });

export const listTasksApiV1TasksGetQueryKey = (options?: Options<ListTasksApiV1TasksGetData>) =>
  createQueryKey('listTasksApiV1TasksGet', options);

/**
 * List Tasks
 *
 * List tasks for the current user with pagination.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetOptions = (options?: Options<ListTasksApiV1TasksGetData>) =>
  queryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    ListTasksApiV1TasksGetResponse,
    ReturnType<typeof listTasksApiV1TasksGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTasksApiV1TasksGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listTasksApiV1TasksGetQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listTasksApiV1TasksGetInfiniteQueryKey = (
  options?: Options<ListTasksApiV1TasksGetData>
): QueryKey<Options<ListTasksApiV1TasksGetData>> =>
  createQueryKey('listTasksApiV1TasksGet', options, true);

/**
 * List Tasks
 *
 * List tasks for the current user with pagination.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetInfiniteOptions = (
  options?: Options<ListTasksApiV1TasksGetData>
) =>
  infiniteQueryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    InfiniteData<ListTasksApiV1TasksGetResponse>,
    QueryKey<Options<ListTasksApiV1TasksGetData>>,
    | number
    | Pick<QueryKey<Options<ListTasksApiV1TasksGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListTasksApiV1TasksGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTasksApiV1TasksGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listTasksApiV1TasksGetInfiniteQueryKey(options),
    }
  );

/**
 * Create Task
 *
 * Create a new coding task.
 *
 * Args:
 * task_data: Task creation data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Created task instance
 */
export const createTaskApiV1TasksPostMutation = (
  options?: Partial<Options<CreateTaskApiV1TasksPostData>>
): UseMutationOptions<
  CreateTaskApiV1TasksPostResponse,
  AxiosError<CreateTaskApiV1TasksPostError>,
  Options<CreateTaskApiV1TasksPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTaskApiV1TasksPostResponse,
    AxiosError<CreateTaskApiV1TasksPostError>,
    Options<CreateTaskApiV1TasksPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createTaskApiV1TasksPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Task
 *
 * Delete a task.
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const deleteTaskApiV1TasksTaskIdDeleteMutation = (
  options?: Partial<Options<DeleteTaskApiV1TasksTaskIdDeleteData>>
): UseMutationOptions<
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
  Options<DeleteTaskApiV1TasksTaskIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTaskApiV1TasksTaskIdDeleteResponse,
    AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
    Options<DeleteTaskApiV1TasksTaskIdDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteTaskApiV1TasksTaskIdDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTaskApiV1TasksTaskIdGetQueryKey = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) => createQueryKey('getTaskApiV1TasksTaskIdGet', options);

/**
 * Get Task
 *
 * Get a specific task by ID.
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Task instance
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const getTaskApiV1TasksTaskIdGetOptions = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) =>
  queryOptions<
    GetTaskApiV1TasksTaskIdGetResponse,
    AxiosError<GetTaskApiV1TasksTaskIdGetError>,
    GetTaskApiV1TasksTaskIdGetResponse,
    ReturnType<typeof getTaskApiV1TasksTaskIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskApiV1TasksTaskIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskApiV1TasksTaskIdGetQueryKey(options),
  });

/**
 * Update Task
 *
 * Update a task.
 *
 * Args:
 * task_id: Task ID
 * task_data: Task update data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Updated task instance
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const updateTaskApiV1TasksTaskIdPatchMutation = (
  options?: Partial<Options<UpdateTaskApiV1TasksTaskIdPatchData>>
): UseMutationOptions<
  UpdateTaskApiV1TasksTaskIdPatchResponse,
  AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
  Options<UpdateTaskApiV1TasksTaskIdPatchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTaskApiV1TasksTaskIdPatchResponse,
    AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
    Options<UpdateTaskApiV1TasksTaskIdPatchData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateTaskApiV1TasksTaskIdPatch({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey = (
  options?: Options<GetTwoFactorStatusApiV1TwoFactorStatusGetData>
) => createQueryKey('getTwoFactorStatusApiV1TwoFactorStatusGet', options);

/**
 * Get Two Factor Status
 *
 * Get the current 2FA status for the authenticated user.
 *
 * Returns:
 * TwoFactorStatusResponse with enabled status and remaining backup codes.
 */
export const getTwoFactorStatusApiV1TwoFactorStatusGetOptions = (
  options?: Options<GetTwoFactorStatusApiV1TwoFactorStatusGetData>
) =>
  queryOptions<
    GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
    AxiosError<GetTwoFactorStatusApiV1TwoFactorStatusGetError>,
    GetTwoFactorStatusApiV1TwoFactorStatusGetResponse,
    ReturnType<typeof getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTwoFactorStatusApiV1TwoFactorStatusGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTwoFactorStatusApiV1TwoFactorStatusGetQueryKey(options),
  });

/**
 * Setup Two Factor
 *
 * Start the 2FA setup process.
 *
 * Generates a TOTP secret and QR code for the user to scan with their
 * authenticator app.
 *
 * Returns:
 * TwoFactorSetupResponse with QR code and secret.
 *
 * Raises:
 * HTTPException: If 2FA is already enabled.
 */
export const setupTwoFactorApiV1TwoFactorSetupPostMutation = (
  options?: Partial<Options<SetupTwoFactorApiV1TwoFactorSetupPostData>>
): UseMutationOptions<
  SetupTwoFactorApiV1TwoFactorSetupPostResponse,
  AxiosError<SetupTwoFactorApiV1TwoFactorSetupPostError>,
  Options<SetupTwoFactorApiV1TwoFactorSetupPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SetupTwoFactorApiV1TwoFactorSetupPostResponse,
    AxiosError<SetupTwoFactorApiV1TwoFactorSetupPostError>,
    Options<SetupTwoFactorApiV1TwoFactorSetupPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await setupTwoFactorApiV1TwoFactorSetupPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enable Two Factor
 *
 * Enable 2FA after verifying the TOTP code.
 *
 * The user must first call /two-factor/setup and scan the QR code before
 * calling this endpoint with the code from their authenticator app.
 *
 * Args:
 * request: Contains the 6-digit TOTP code.
 *
 * Returns:
 * TwoFactorEnableResponse with backup codes.
 *
 * Raises:
 * HTTPException: If the code is invalid or 2FA is not set up.
 */
export const enableTwoFactorApiV1TwoFactorEnablePostMutation = (
  options?: Partial<Options<EnableTwoFactorApiV1TwoFactorEnablePostData>>
): UseMutationOptions<
  EnableTwoFactorApiV1TwoFactorEnablePostResponse,
  AxiosError<EnableTwoFactorApiV1TwoFactorEnablePostError>,
  Options<EnableTwoFactorApiV1TwoFactorEnablePostData>
> => {
  const mutationOptions: UseMutationOptions<
    EnableTwoFactorApiV1TwoFactorEnablePostResponse,
    AxiosError<EnableTwoFactorApiV1TwoFactorEnablePostError>,
    Options<EnableTwoFactorApiV1TwoFactorEnablePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await enableTwoFactorApiV1TwoFactorEnablePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Disable Two Factor
 *
 * Disable 2FA for the authenticated user.
 *
 * Requires the user's password for confirmation.
 *
 * Args:
 * request: Contains the user's password.
 *
 * Returns:
 * Success message.
 *
 * Raises:
 * HTTPException: If 2FA is not enabled or password is incorrect.
 */
export const disableTwoFactorApiV1TwoFactorDisablePostMutation = (
  options?: Partial<Options<DisableTwoFactorApiV1TwoFactorDisablePostData>>
): UseMutationOptions<
  DisableTwoFactorApiV1TwoFactorDisablePostResponse,
  AxiosError<DisableTwoFactorApiV1TwoFactorDisablePostError>,
  Options<DisableTwoFactorApiV1TwoFactorDisablePostData>
> => {
  const mutationOptions: UseMutationOptions<
    DisableTwoFactorApiV1TwoFactorDisablePostResponse,
    AxiosError<DisableTwoFactorApiV1TwoFactorDisablePostError>,
    Options<DisableTwoFactorApiV1TwoFactorDisablePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await disableTwoFactorApiV1TwoFactorDisablePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Verify Two Factor
 *
 * Verify a 2FA code (TOTP or backup code).
 *
 * This endpoint can be used during login or for sensitive operations.
 *
 * Args:
 * request: Contains the TOTP or backup code.
 *
 * Returns:
 * TwoFactorVerifyResponse indicating if the code is valid.
 */
export const verifyTwoFactorApiV1TwoFactorVerifyPostMutation = (
  options?: Partial<Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>>
): UseMutationOptions<
  VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
  AxiosError<VerifyTwoFactorApiV1TwoFactorVerifyPostError>,
  Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyTwoFactorApiV1TwoFactorVerifyPostResponse,
    AxiosError<VerifyTwoFactorApiV1TwoFactorVerifyPostError>,
    Options<VerifyTwoFactorApiV1TwoFactorVerifyPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyTwoFactorApiV1TwoFactorVerifyPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Regenerate Backup Codes
 *
 * Regenerate backup codes for the authenticated user.
 *
 * This invalidates all existing backup codes and generates new ones.
 * Requires the user's password for confirmation.
 *
 * Args:
 * request: Contains the user's password.
 *
 * Returns:
 * RegenerateBackupCodesResponse with new backup codes.
 *
 * Raises:
 * HTTPException: If 2FA is not enabled or password is incorrect.
 */
export const regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostMutation = (
  options?: Partial<Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>>
): UseMutationOptions<
  RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
  AxiosError<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError>,
  Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostResponse,
    AxiosError<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostError>,
    Options<RegenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await regenerateBackupCodesApiV1TwoFactorRegenerateBackupCodesPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOauthProvidersApiV1OauthProvidersGetQueryKey = (
  options?: Options<GetOauthProvidersApiV1OauthProvidersGetData>
) => createQueryKey('getOauthProvidersApiV1OauthProvidersGet', options);

/**
 * Get Oauth Providers
 *
 * Get available OAuth providers and their configuration status.
 *
 * Returns:
 * Dictionary of provider names and whether they are configured.
 */
export const getOauthProvidersApiV1OauthProvidersGetOptions = (
  options?: Options<GetOauthProvidersApiV1OauthProvidersGetData>
) =>
  queryOptions<
    GetOauthProvidersApiV1OauthProvidersGetResponse,
    AxiosError<DefaultError>,
    GetOauthProvidersApiV1OauthProvidersGetResponse,
    ReturnType<typeof getOauthProvidersApiV1OauthProvidersGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOauthProvidersApiV1OauthProvidersGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOauthProvidersApiV1OauthProvidersGetQueryKey(options),
  });

export const oauthAuthorizeApiV1OauthProviderAuthorizeGetQueryKey = (
  options: Options<OauthAuthorizeApiV1OauthProviderAuthorizeGetData>
) => createQueryKey('oauthAuthorizeApiV1OauthProviderAuthorizeGet', options);

/**
 * Oauth Authorize
 *
 * Start OAuth authorization flow.
 *
 * Redirects the user to the OAuth provider's authorization page.
 *
 * Args:
 * provider: OAuth provider name (github, google, microsoft).
 * redirect_url: Optional URL to redirect to after successful auth.
 *
 * Returns:
 * Redirect to the OAuth provider.
 *
 * Raises:
 * HTTPException: If provider is not supported or not configured.
 */
export const oauthAuthorizeApiV1OauthProviderAuthorizeGetOptions = (
  options: Options<OauthAuthorizeApiV1OauthProviderAuthorizeGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthAuthorizeApiV1OauthProviderAuthorizeGetError>,
    unknown,
    ReturnType<typeof oauthAuthorizeApiV1OauthProviderAuthorizeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthAuthorizeApiV1OauthProviderAuthorizeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthAuthorizeApiV1OauthProviderAuthorizeGetQueryKey(options),
  });

export const oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetQueryKey = (
  options: Options<OauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetData>
) => createQueryKey('oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGet', options);

/**
 * Oauth Authorize Link
 *
 * Start OAuth authorization flow for linking to existing account.
 *
 * Requires authentication. Links the OAuth account to the current user.
 *
 * Args:
 * provider: OAuth provider name.
 * redirect_url: Optional URL to redirect to after linking.
 *
 * Returns:
 * Redirect to the OAuth provider.
 */
export const oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetOptions = (
  options: Options<OauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetError>,
    unknown,
    ReturnType<typeof oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthAuthorizeLinkApiV1OauthProviderAuthorizeLinkGetQueryKey(options),
  });

export const oauthCallbackApiV1OauthProviderCallbackGetQueryKey = (
  options: Options<OauthCallbackApiV1OauthProviderCallbackGetData>
) => createQueryKey('oauthCallbackApiV1OauthProviderCallbackGet', options);

/**
 * Oauth Callback
 *
 * Handle OAuth callback.
 *
 * Exchanges the authorization code for tokens and creates/links user account.
 * Then redirects to frontend with success/error status.
 *
 * Args:
 * provider: OAuth provider name.
 * code: Authorization code from OAuth provider.
 * state: CSRF protection state.
 *
 * Returns:
 * Redirect to frontend.
 *
 * Raises:
 * HTTPException: If callback fails.
 */
export const oauthCallbackApiV1OauthProviderCallbackGetOptions = (
  options: Options<OauthCallbackApiV1OauthProviderCallbackGetData>
) =>
  queryOptions<
    unknown,
    AxiosError<OauthCallbackApiV1OauthProviderCallbackGetError>,
    unknown,
    ReturnType<typeof oauthCallbackApiV1OauthProviderCallbackGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauthCallbackApiV1OauthProviderCallbackGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauthCallbackApiV1OauthProviderCallbackGetQueryKey(options),
  });

export const getConnectedAccountsApiV1OauthAccountsGetQueryKey = (
  options?: Options<GetConnectedAccountsApiV1OauthAccountsGetData>
) => createQueryKey('getConnectedAccountsApiV1OauthAccountsGet', options);

/**
 * Get Connected Accounts
 *
 * Get all OAuth accounts linked to the current user.
 *
 * Returns:
 * List of connected OAuth accounts.
 */
export const getConnectedAccountsApiV1OauthAccountsGetOptions = (
  options?: Options<GetConnectedAccountsApiV1OauthAccountsGetData>
) =>
  queryOptions<
    GetConnectedAccountsApiV1OauthAccountsGetResponse,
    AxiosError<GetConnectedAccountsApiV1OauthAccountsGetError>,
    GetConnectedAccountsApiV1OauthAccountsGetResponse,
    ReturnType<typeof getConnectedAccountsApiV1OauthAccountsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getConnectedAccountsApiV1OauthAccountsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getConnectedAccountsApiV1OauthAccountsGetQueryKey(options),
  });

/**
 * Unlink Oauth Account
 *
 * Unlink an OAuth account from the current user.
 *
 * Args:
 * provider: OAuth provider to unlink.
 *
 * Returns:
 * Success message.
 *
 * Raises:
 * HTTPException: If unlinking fails.
 */
export const unlinkOauthAccountApiV1OauthProviderUnlinkDeleteMutation = (
  options?: Partial<Options<UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteData>>
): UseMutationOptions<
  UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteResponse,
  AxiosError<UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteError>,
  Options<UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteResponse,
    AxiosError<UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteError>,
    Options<UnlinkOauthAccountApiV1OauthProviderUnlinkDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await unlinkOauthAccountApiV1OauthProviderUnlinkDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Send Test Email
 *
 * Send a test email to verify SMTP configuration.
 *
 * **Development Only** - Remove this endpoint in production.
 *
 * Args:
 * recipient_email: Email address to send test email to
 * db: Database session
 *
 * Returns:
 * dict: Success message with details
 *
 * Raises:
 * HTTPException: If email sending fails
 */
export const sendTestEmailApiV1TestSendTestEmailPostMutation = (
  options?: Partial<Options<SendTestEmailApiV1TestSendTestEmailPostData>>
): UseMutationOptions<
  SendTestEmailApiV1TestSendTestEmailPostResponse,
  AxiosError<SendTestEmailApiV1TestSendTestEmailPostError>,
  Options<SendTestEmailApiV1TestSendTestEmailPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SendTestEmailApiV1TestSendTestEmailPostResponse,
    AxiosError<SendTestEmailApiV1TestSendTestEmailPostError>,
    Options<SendTestEmailApiV1TestSendTestEmailPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await sendTestEmailApiV1TestSendTestEmailPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
