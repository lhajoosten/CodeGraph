// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import {
  createTaskApiV1TasksPost,
  deleteTaskApiV1TasksTaskIdDelete,
  getCurrentUserInfoApiV1UsersMeGet,
  getTaskApiV1TasksTaskIdGet,
  healthCheckHealthGet,
  listTasksApiV1TasksGet,
  loginUserApiV1AuthLoginPost,
  type Options,
  registerUserApiV1AuthRegisterPost,
  updateTaskApiV1TasksTaskIdPatch,
} from '../sdk.gen';
import type {
  CreateTaskApiV1TasksPostData,
  CreateTaskApiV1TasksPostError,
  CreateTaskApiV1TasksPostResponse,
  DeleteTaskApiV1TasksTaskIdDeleteData,
  DeleteTaskApiV1TasksTaskIdDeleteError,
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  GetCurrentUserInfoApiV1UsersMeGetData,
  GetCurrentUserInfoApiV1UsersMeGetResponse,
  GetTaskApiV1TasksTaskIdGetData,
  GetTaskApiV1TasksTaskIdGetError,
  GetTaskApiV1TasksTaskIdGetResponse,
  HealthCheckHealthGetData,
  HealthCheckHealthGetResponse,
  ListTasksApiV1TasksGetData,
  ListTasksApiV1TasksGetError,
  ListTasksApiV1TasksGetResponse,
  LoginUserApiV1AuthLoginPostData,
  LoginUserApiV1AuthLoginPostError,
  LoginUserApiV1AuthLoginPostResponse,
  RegisterUserApiV1AuthRegisterPostData,
  RegisterUserApiV1AuthRegisterPostError,
  RegisterUserApiV1AuthRegisterPostResponse,
  UpdateTaskApiV1TasksTaskIdPatchData,
  UpdateTaskApiV1TasksTaskIdPatchError,
  UpdateTaskApiV1TasksTaskIdPatchResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckHealthGetQueryKey = (options?: Options<HealthCheckHealthGetData>) =>
  createQueryKey('healthCheckHealthGet', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns:
 * Dictionary with status message
 */
export const healthCheckHealthGetOptions = (options?: Options<HealthCheckHealthGetData>) =>
  queryOptions<
    HealthCheckHealthGetResponse,
    AxiosError<DefaultError>,
    HealthCheckHealthGetResponse,
    ReturnType<typeof healthCheckHealthGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options),
  });

/**
 * Register User
 *
 * Register a new user.
 *
 * Args:
 * user_data: User registration data
 * db: Database session
 *
 * Returns:
 * Created user instance
 *
 * Raises:
 * HTTPException: If email already exists
 */
export const registerUserApiV1AuthRegisterPostMutation = (
  options?: Partial<Options<RegisterUserApiV1AuthRegisterPostData>>
): UseMutationOptions<
  RegisterUserApiV1AuthRegisterPostResponse,
  AxiosError<RegisterUserApiV1AuthRegisterPostError>,
  Options<RegisterUserApiV1AuthRegisterPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegisterUserApiV1AuthRegisterPostResponse,
    AxiosError<RegisterUserApiV1AuthRegisterPostError>,
    Options<RegisterUserApiV1AuthRegisterPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await registerUserApiV1AuthRegisterPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login User
 *
 * Authenticate user and return JWT tokens.
 *
 * Args:
 * user_data: User login credentials
 * db: Database session
 *
 * Returns:
 * JWT access and refresh tokens
 *
 * Raises:
 * HTTPException: If credentials are invalid
 */
export const loginUserApiV1AuthLoginPostMutation = (
  options?: Partial<Options<LoginUserApiV1AuthLoginPostData>>
): UseMutationOptions<
  LoginUserApiV1AuthLoginPostResponse,
  AxiosError<LoginUserApiV1AuthLoginPostError>,
  Options<LoginUserApiV1AuthLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LoginUserApiV1AuthLoginPostResponse,
    AxiosError<LoginUserApiV1AuthLoginPostError>,
    Options<LoginUserApiV1AuthLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loginUserApiV1AuthLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1UsersMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1UsersMeGet', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Args:
 * current_user: Current authenticated user
 *
 * Returns:
 * Current user data
 */
export const getCurrentUserInfoApiV1UsersMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1UsersMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    AxiosError<DefaultError>,
    GetCurrentUserInfoApiV1UsersMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1UsersMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1UsersMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1UsersMeGetQueryKey(options),
  });

export const listTasksApiV1TasksGetQueryKey = (options?: Options<ListTasksApiV1TasksGetData>) =>
  createQueryKey('listTasksApiV1TasksGet', options);

/**
 * List Tasks
 *
 * List tasks for the current user with pagination.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetOptions = (options?: Options<ListTasksApiV1TasksGetData>) =>
  queryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    ListTasksApiV1TasksGetResponse,
    ReturnType<typeof listTasksApiV1TasksGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTasksApiV1TasksGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listTasksApiV1TasksGetQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listTasksApiV1TasksGetInfiniteQueryKey = (
  options?: Options<ListTasksApiV1TasksGetData>
): QueryKey<Options<ListTasksApiV1TasksGetData>> =>
  createQueryKey('listTasksApiV1TasksGet', options, true);

/**
 * List Tasks
 *
 * List tasks for the current user with pagination.
 *
 * Args:
 * db: Database session
 * current_user: Current authenticated user
 * page: Page number (starts at 1)
 * page_size: Number of items per page
 *
 * Returns:
 * Paginated list of tasks
 */
export const listTasksApiV1TasksGetInfiniteOptions = (
  options?: Options<ListTasksApiV1TasksGetData>
) =>
  infiniteQueryOptions<
    ListTasksApiV1TasksGetResponse,
    AxiosError<ListTasksApiV1TasksGetError>,
    InfiniteData<ListTasksApiV1TasksGetResponse>,
    QueryKey<Options<ListTasksApiV1TasksGetData>>,
    | number
    | Pick<QueryKey<Options<ListTasksApiV1TasksGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListTasksApiV1TasksGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTasksApiV1TasksGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listTasksApiV1TasksGetInfiniteQueryKey(options),
    }
  );

/**
 * Create Task
 *
 * Create a new coding task.
 *
 * Args:
 * task_data: Task creation data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Created task instance
 */
export const createTaskApiV1TasksPostMutation = (
  options?: Partial<Options<CreateTaskApiV1TasksPostData>>
): UseMutationOptions<
  CreateTaskApiV1TasksPostResponse,
  AxiosError<CreateTaskApiV1TasksPostError>,
  Options<CreateTaskApiV1TasksPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTaskApiV1TasksPostResponse,
    AxiosError<CreateTaskApiV1TasksPostError>,
    Options<CreateTaskApiV1TasksPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createTaskApiV1TasksPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Task
 *
 * Delete a task.
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const deleteTaskApiV1TasksTaskIdDeleteMutation = (
  options?: Partial<Options<DeleteTaskApiV1TasksTaskIdDeleteData>>
): UseMutationOptions<
  DeleteTaskApiV1TasksTaskIdDeleteResponse,
  AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
  Options<DeleteTaskApiV1TasksTaskIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTaskApiV1TasksTaskIdDeleteResponse,
    AxiosError<DeleteTaskApiV1TasksTaskIdDeleteError>,
    Options<DeleteTaskApiV1TasksTaskIdDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteTaskApiV1TasksTaskIdDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTaskApiV1TasksTaskIdGetQueryKey = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) => createQueryKey('getTaskApiV1TasksTaskIdGet', options);

/**
 * Get Task
 *
 * Get a specific task by ID.
 *
 * Args:
 * task_id: Task ID
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Task instance
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const getTaskApiV1TasksTaskIdGetOptions = (
  options: Options<GetTaskApiV1TasksTaskIdGetData>
) =>
  queryOptions<
    GetTaskApiV1TasksTaskIdGetResponse,
    AxiosError<GetTaskApiV1TasksTaskIdGetError>,
    GetTaskApiV1TasksTaskIdGetResponse,
    ReturnType<typeof getTaskApiV1TasksTaskIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTaskApiV1TasksTaskIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTaskApiV1TasksTaskIdGetQueryKey(options),
  });

/**
 * Update Task
 *
 * Update a task.
 *
 * Args:
 * task_id: Task ID
 * task_data: Task update data
 * db: Database session
 * current_user: Current authenticated user
 *
 * Returns:
 * Updated task instance
 *
 * Raises:
 * HTTPException: If task not found or unauthorized
 */
export const updateTaskApiV1TasksTaskIdPatchMutation = (
  options?: Partial<Options<UpdateTaskApiV1TasksTaskIdPatchData>>
): UseMutationOptions<
  UpdateTaskApiV1TasksTaskIdPatchResponse,
  AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
  Options<UpdateTaskApiV1TasksTaskIdPatchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTaskApiV1TasksTaskIdPatchResponse,
    AxiosError<UpdateTaskApiV1TasksTaskIdPatchError>,
    Options<UpdateTaskApiV1TasksTaskIdPatchData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateTaskApiV1TasksTaskIdPatch({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
